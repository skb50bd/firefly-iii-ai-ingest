// <auto-generated>
/*
 * Firefly III API v6.3.0
 *
 * This is the documentation of the Firefly III API. Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. <br><br> Please keep in mind that the demo site does **not** accept requests from `curl`, `colly`, `wget`, etc. You must use a browser or a tool like Insomnia to make your test requests. <br><br> To learn more about the idiosyncrasies of this API, please read about the API in the [Firefly III API documentation](https://docs.firefly-iii.org/references/firefly-iii/api/). <br><br> <small>This file was last generated on 2025-08-16 @ 20:21:49 (Europe/Amsterdam)</small> 
 *
 * The version of the OpenAPI document: v6.3.0
 * Contact: james@firefly-iii.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Brotal.FireflyIII.Client;
using Brotal.FireflyIII.Model;
using System.Diagnostics.CodeAnalysis;

namespace Brotal.FireflyIII.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IInsightApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        InsightApiEvents Events { get; }

        /// <summary>
        /// Insight into expenses, grouped by asset account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseAssetApiResponse"/>&gt;</returns>
        Task<IInsightExpenseAssetApiResponse> InsightExpenseAssetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by asset account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseAssetApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseAssetApiResponse?> InsightExpenseAssetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by bill.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="bills">The bills to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBillApiResponse"/>&gt;</returns>
        Task<IInsightExpenseBillApiResponse> InsightExpenseBillAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> bills = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by bill.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="bills">The bills to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBillApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseBillApiResponse?> InsightExpenseBillOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> bills = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by budget.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="budgets">The budgets to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBudgetApiResponse"/>&gt;</returns>
        Task<IInsightExpenseBudgetApiResponse> InsightExpenseBudgetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> budgets = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by budget.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="budgets">The budgets to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBudgetApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseBudgetApiResponse?> InsightExpenseBudgetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> budgets = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseCategoryApiResponse"/>&gt;</returns>
        Task<IInsightExpenseCategoryApiResponse> InsightExpenseCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseCategoryApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseCategoryApiResponse?> InsightExpenseCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by expense account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of expense accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseExpenseApiResponse"/>&gt;</returns>
        Task<IInsightExpenseExpenseApiResponse> InsightExpenseExpenseAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by expense account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of expense accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseExpenseApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseExpenseApiResponse?> InsightExpenseExpenseOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without bill.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBillApiResponse"/>&gt;</returns>
        Task<IInsightExpenseNoBillApiResponse> InsightExpenseNoBillAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without bill.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBillApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseNoBillApiResponse?> InsightExpenseNoBillOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without budget.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBudgetApiResponse"/>&gt;</returns>
        Task<IInsightExpenseNoBudgetApiResponse> InsightExpenseNoBudgetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without budget.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBudgetApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseNoBudgetApiResponse?> InsightExpenseNoBudgetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoCategoryApiResponse"/>&gt;</returns>
        Task<IInsightExpenseNoCategoryApiResponse> InsightExpenseNoCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoCategoryApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseNoCategoryApiResponse?> InsightExpenseNoCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoTagApiResponse"/>&gt;</returns>
        Task<IInsightExpenseNoTagApiResponse> InsightExpenseNoTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoTagApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseNoTagApiResponse?> InsightExpenseNoTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTagApiResponse"/>&gt;</returns>
        Task<IInsightExpenseTagApiResponse> InsightExpenseTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, grouped by tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTagApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseTagApiResponse?> InsightExpenseTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into total expenses.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a sum of the total expenses made by the user. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTotalApiResponse"/>&gt;</returns>
        Task<IInsightExpenseTotalApiResponse> InsightExpenseTotalAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into total expenses.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a sum of the total expenses made by the user. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTotalApiResponse"/>?&gt;</returns>
        Task<IInsightExpenseTotalApiResponse?> InsightExpenseTotalOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by asset account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by asset account. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeAssetApiResponse"/>&gt;</returns>
        Task<IInsightIncomeAssetApiResponse> InsightIncomeAssetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by asset account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by asset account. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeAssetApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeAssetApiResponse?> InsightIncomeAssetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by (any) category. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeCategoryApiResponse"/>&gt;</returns>
        Task<IInsightIncomeCategoryApiResponse> InsightIncomeCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by (any) category. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeCategoryApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeCategoryApiResponse?> InsightIncomeCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, without category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, including only income with no category. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoCategoryApiResponse"/>&gt;</returns>
        Task<IInsightIncomeNoCategoryApiResponse> InsightIncomeNoCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, without category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, including only income with no category. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoCategoryApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeNoCategoryApiResponse?> InsightIncomeNoCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, without tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, including only income with no tag. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoTagApiResponse"/>&gt;</returns>
        Task<IInsightIncomeNoTagApiResponse> InsightIncomeNoTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, without tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, including only income with no tag. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoTagApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeNoTagApiResponse?> InsightIncomeNoTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by revenue account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by revenue account. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of revenue accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeRevenueApiResponse"/>&gt;</returns>
        Task<IInsightIncomeRevenueApiResponse> InsightIncomeRevenueAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by revenue account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by revenue account. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of revenue accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeRevenueApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeRevenueApiResponse?> InsightIncomeRevenueOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTagApiResponse"/>&gt;</returns>
        Task<IInsightIncomeTagApiResponse> InsightIncomeTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into income, grouped by tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTagApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeTagApiResponse?> InsightIncomeTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into total income.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a sum of the total income received by the user. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTotalApiResponse"/>&gt;</returns>
        Task<IInsightIncomeTotalApiResponse> InsightIncomeTotalAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into total income.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a sum of the total income received by the user. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTotalApiResponse"/>?&gt;</returns>
        Task<IInsightIncomeTotalApiResponse?> InsightIncomeTotalOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, grouped by category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferCategoryApiResponse"/>&gt;</returns>
        Task<IInsightTransferCategoryApiResponse> InsightTransferCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, grouped by category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferCategoryApiResponse"/>?&gt;</returns>
        Task<IInsightTransferCategoryApiResponse?> InsightTransferCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, without category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoCategoryApiResponse"/>&gt;</returns>
        Task<IInsightTransferNoCategoryApiResponse> InsightTransferNoCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, without category.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoCategoryApiResponse"/>?&gt;</returns>
        Task<IInsightTransferNoCategoryApiResponse?> InsightTransferNoCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoTagApiResponse"/>&gt;</returns>
        Task<IInsightTransferNoTagApiResponse> InsightTransferNoTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into expenses, without tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoTagApiResponse"/>?&gt;</returns>
        Task<IInsightTransferNoTagApiResponse?> InsightTransferNoTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, grouped by tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTagApiResponse"/>&gt;</returns>
        Task<IInsightTransferTagApiResponse> InsightTransferTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, grouped by tag.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTagApiResponse"/>?&gt;</returns>
        Task<IInsightTransferTagApiResponse?> InsightTransferTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into total transfers.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a sum of the total amount transfers made by the user. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTotalApiResponse"/>&gt;</returns>
        Task<IInsightTransferTotalApiResponse> InsightTransferTotalAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into total transfers.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a sum of the total amount transfers made by the user. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTotalApiResponse"/>?&gt;</returns>
        Task<IInsightTransferTotalApiResponse?> InsightTransferTotalOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, grouped by account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransfersApiResponse"/>&gt;</returns>
        Task<IInsightTransfersApiResponse> InsightTransfersAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Insight into transfers, grouped by account.
        /// </summary>
        /// <remarks>
        /// This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransfersApiResponse"/>?&gt;</returns>
        Task<IInsightTransfersApiResponse?> InsightTransfersOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IInsightExpenseAssetApiResponse"/>
    /// </summary>
    public interface IInsightExpenseAssetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseBillApiResponse"/>
    /// </summary>
    public interface IInsightExpenseBillApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseBudgetApiResponse"/>
    /// </summary>
    public interface IInsightExpenseBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseCategoryApiResponse"/>
    /// </summary>
    public interface IInsightExpenseCategoryApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseExpenseApiResponse"/>
    /// </summary>
    public interface IInsightExpenseExpenseApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseNoBillApiResponse"/>
    /// </summary>
    public interface IInsightExpenseNoBillApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseNoBudgetApiResponse"/>
    /// </summary>
    public interface IInsightExpenseNoBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseNoCategoryApiResponse"/>
    /// </summary>
    public interface IInsightExpenseNoCategoryApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseNoTagApiResponse"/>
    /// </summary>
    public interface IInsightExpenseNoTagApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseTagApiResponse"/>
    /// </summary>
    public interface IInsightExpenseTagApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightExpenseTotalApiResponse"/>
    /// </summary>
    public interface IInsightExpenseTotalApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeAssetApiResponse"/>
    /// </summary>
    public interface IInsightIncomeAssetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeCategoryApiResponse"/>
    /// </summary>
    public interface IInsightIncomeCategoryApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeNoCategoryApiResponse"/>
    /// </summary>
    public interface IInsightIncomeNoCategoryApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeNoTagApiResponse"/>
    /// </summary>
    public interface IInsightIncomeNoTagApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeRevenueApiResponse"/>
    /// </summary>
    public interface IInsightIncomeRevenueApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeTagApiResponse"/>
    /// </summary>
    public interface IInsightIncomeTagApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightIncomeTotalApiResponse"/>
    /// </summary>
    public interface IInsightIncomeTotalApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightTransferCategoryApiResponse"/>
    /// </summary>
    public interface IInsightTransferCategoryApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightTransferNoCategoryApiResponse"/>
    /// </summary>
    public interface IInsightTransferNoCategoryApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightTransferNoTagApiResponse"/>
    /// </summary>
    public interface IInsightTransferNoTagApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightTransferTagApiResponse"/>
    /// </summary>
    public interface IInsightTransferTagApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightGroupEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightTransferTotalApiResponse"/>
    /// </summary>
    public interface IInsightTransferTotalApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTotalEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IInsightTransfersApiResponse"/>
    /// </summary>
    public interface IInsightTransfersApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IOk<List<InsightTransferEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class InsightApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseAsset;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseAsset;

        internal void ExecuteOnInsightExpenseAsset(InsightApi.InsightExpenseAssetApiResponse apiResponse)
        {
            OnInsightExpenseAsset?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseAsset(Exception exception)
        {
            OnErrorInsightExpenseAsset?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseBill;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseBill;

        internal void ExecuteOnInsightExpenseBill(InsightApi.InsightExpenseBillApiResponse apiResponse)
        {
            OnInsightExpenseBill?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseBill(Exception exception)
        {
            OnErrorInsightExpenseBill?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseBudget;

        internal void ExecuteOnInsightExpenseBudget(InsightApi.InsightExpenseBudgetApiResponse apiResponse)
        {
            OnInsightExpenseBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseBudget(Exception exception)
        {
            OnErrorInsightExpenseBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseCategory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseCategory;

        internal void ExecuteOnInsightExpenseCategory(InsightApi.InsightExpenseCategoryApiResponse apiResponse)
        {
            OnInsightExpenseCategory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseCategory(Exception exception)
        {
            OnErrorInsightExpenseCategory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseExpense;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseExpense;

        internal void ExecuteOnInsightExpenseExpense(InsightApi.InsightExpenseExpenseApiResponse apiResponse)
        {
            OnInsightExpenseExpense?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseExpense(Exception exception)
        {
            OnErrorInsightExpenseExpense?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseNoBill;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseNoBill;

        internal void ExecuteOnInsightExpenseNoBill(InsightApi.InsightExpenseNoBillApiResponse apiResponse)
        {
            OnInsightExpenseNoBill?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseNoBill(Exception exception)
        {
            OnErrorInsightExpenseNoBill?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseNoBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseNoBudget;

        internal void ExecuteOnInsightExpenseNoBudget(InsightApi.InsightExpenseNoBudgetApiResponse apiResponse)
        {
            OnInsightExpenseNoBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseNoBudget(Exception exception)
        {
            OnErrorInsightExpenseNoBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseNoCategory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseNoCategory;

        internal void ExecuteOnInsightExpenseNoCategory(InsightApi.InsightExpenseNoCategoryApiResponse apiResponse)
        {
            OnInsightExpenseNoCategory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseNoCategory(Exception exception)
        {
            OnErrorInsightExpenseNoCategory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseNoTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseNoTag;

        internal void ExecuteOnInsightExpenseNoTag(InsightApi.InsightExpenseNoTagApiResponse apiResponse)
        {
            OnInsightExpenseNoTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseNoTag(Exception exception)
        {
            OnErrorInsightExpenseNoTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseTag;

        internal void ExecuteOnInsightExpenseTag(InsightApi.InsightExpenseTagApiResponse apiResponse)
        {
            OnInsightExpenseTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseTag(Exception exception)
        {
            OnErrorInsightExpenseTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightExpenseTotal;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightExpenseTotal;

        internal void ExecuteOnInsightExpenseTotal(InsightApi.InsightExpenseTotalApiResponse apiResponse)
        {
            OnInsightExpenseTotal?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightExpenseTotal(Exception exception)
        {
            OnErrorInsightExpenseTotal?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeAsset;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeAsset;

        internal void ExecuteOnInsightIncomeAsset(InsightApi.InsightIncomeAssetApiResponse apiResponse)
        {
            OnInsightIncomeAsset?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeAsset(Exception exception)
        {
            OnErrorInsightIncomeAsset?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeCategory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeCategory;

        internal void ExecuteOnInsightIncomeCategory(InsightApi.InsightIncomeCategoryApiResponse apiResponse)
        {
            OnInsightIncomeCategory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeCategory(Exception exception)
        {
            OnErrorInsightIncomeCategory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeNoCategory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeNoCategory;

        internal void ExecuteOnInsightIncomeNoCategory(InsightApi.InsightIncomeNoCategoryApiResponse apiResponse)
        {
            OnInsightIncomeNoCategory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeNoCategory(Exception exception)
        {
            OnErrorInsightIncomeNoCategory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeNoTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeNoTag;

        internal void ExecuteOnInsightIncomeNoTag(InsightApi.InsightIncomeNoTagApiResponse apiResponse)
        {
            OnInsightIncomeNoTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeNoTag(Exception exception)
        {
            OnErrorInsightIncomeNoTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeRevenue;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeRevenue;

        internal void ExecuteOnInsightIncomeRevenue(InsightApi.InsightIncomeRevenueApiResponse apiResponse)
        {
            OnInsightIncomeRevenue?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeRevenue(Exception exception)
        {
            OnErrorInsightIncomeRevenue?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeTag;

        internal void ExecuteOnInsightIncomeTag(InsightApi.InsightIncomeTagApiResponse apiResponse)
        {
            OnInsightIncomeTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeTag(Exception exception)
        {
            OnErrorInsightIncomeTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightIncomeTotal;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightIncomeTotal;

        internal void ExecuteOnInsightIncomeTotal(InsightApi.InsightIncomeTotalApiResponse apiResponse)
        {
            OnInsightIncomeTotal?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightIncomeTotal(Exception exception)
        {
            OnErrorInsightIncomeTotal?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightTransferCategory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightTransferCategory;

        internal void ExecuteOnInsightTransferCategory(InsightApi.InsightTransferCategoryApiResponse apiResponse)
        {
            OnInsightTransferCategory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightTransferCategory(Exception exception)
        {
            OnErrorInsightTransferCategory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightTransferNoCategory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightTransferNoCategory;

        internal void ExecuteOnInsightTransferNoCategory(InsightApi.InsightTransferNoCategoryApiResponse apiResponse)
        {
            OnInsightTransferNoCategory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightTransferNoCategory(Exception exception)
        {
            OnErrorInsightTransferNoCategory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightTransferNoTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightTransferNoTag;

        internal void ExecuteOnInsightTransferNoTag(InsightApi.InsightTransferNoTagApiResponse apiResponse)
        {
            OnInsightTransferNoTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightTransferNoTag(Exception exception)
        {
            OnErrorInsightTransferNoTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightTransferTag;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightTransferTag;

        internal void ExecuteOnInsightTransferTag(InsightApi.InsightTransferTagApiResponse apiResponse)
        {
            OnInsightTransferTag?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightTransferTag(Exception exception)
        {
            OnErrorInsightTransferTag?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightTransferTotal;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightTransferTotal;

        internal void ExecuteOnInsightTransferTotal(InsightApi.InsightTransferTotalApiResponse apiResponse)
        {
            OnInsightTransferTotal?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightTransferTotal(Exception exception)
        {
            OnErrorInsightTransferTotal?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnInsightTransfers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorInsightTransfers;

        internal void ExecuteOnInsightTransfers(InsightApi.InsightTransfersApiResponse apiResponse)
        {
            OnInsightTransfers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorInsightTransfers(Exception exception)
        {
            OnErrorInsightTransfers?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class InsightApi : IInsightApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<InsightApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public InsightApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="InsightApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InsightApi(ILogger<InsightApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, InsightApiEvents insightApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<InsightApi>();
            HttpClient = httpClient;
            Events = insightApiEvents;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatInsightExpenseAsset(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseAsset(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseAssetDefaultImplementation(IInsightExpenseAssetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseAsset(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseAsset(ref bool suppressDefaultLog, IInsightExpenseAssetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseAssetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseAsset(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseAsset(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, grouped by asset account. This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseAssetApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseAssetApiResponse?> InsightExpenseAssetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseAssetAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, grouped by asset account. This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseAssetApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseAssetApiResponse> InsightExpenseAssetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseAsset(accounts);

                FormatInsightExpenseAsset(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/asset"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/asset");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseAssetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseAssetApiResponse>();
                        InsightExpenseAssetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/asset", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseAssetDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseAsset(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseAssetDefaultImplementation(e, "/v1/insight/expense/asset", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseAsset(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseAssetApiResponse"/>
        /// </summary>
        public partial class InsightExpenseAssetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseAssetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseAssetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseAssetApiResponse(ILogger<InsightExpenseAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseAssetApiResponse(ILogger<InsightExpenseAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseBill(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> bills, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bills"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseBill(Option<List<long>> bills, Option<List<long>> accounts)
        {
            if (bills.IsSet && bills.Value == null)
                throw new ArgumentNullException(nameof(bills));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="bills"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseBillDefaultImplementation(IInsightExpenseBillApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> bills, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseBill(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, bills, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="bills"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseBill(ref bool suppressDefaultLog, IInsightExpenseBillApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> bills, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="bills"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseBillDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> bills, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseBill(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, bills, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="bills"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseBill(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> bills, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, grouped by bill. This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="bills">The bills to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBillApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseBillApiResponse?> InsightExpenseBillOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> bills = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseBillAsync(start, end, xTraceId, bills, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, grouped by bill. This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="bills">The bills to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBillApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseBillApiResponse> InsightExpenseBillAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> bills = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseBill(bills, accounts);

                FormatInsightExpenseBill(ref start, ref end, ref xTraceId, bills, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/bill"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/bill");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (bills.IsSet)
                        parseQueryStringLocalVar["bills[]"] = ClientUtils.ParameterToString(bills.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseBillApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseBillApiResponse>();
                        InsightExpenseBillApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/bill", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseBillDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, bills, accounts);

                        Events.ExecuteOnInsightExpenseBill(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseBillDefaultImplementation(e, "/v1/insight/expense/bill", uriBuilderLocalVar.Path, start, end, xTraceId, bills, accounts);
                Events.ExecuteOnErrorInsightExpenseBill(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseBillApiResponse"/>
        /// </summary>
        public partial class InsightExpenseBillApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseBillApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseBillApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseBillApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseBillApiResponse(ILogger<InsightExpenseBillApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseBillApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseBillApiResponse(ILogger<InsightExpenseBillApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseBudget(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> budgets, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="budgets"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseBudget(Option<List<long>> budgets, Option<List<long>> accounts)
        {
            if (budgets.IsSet && budgets.Value == null)
                throw new ArgumentNullException(nameof(budgets));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="budgets"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseBudgetDefaultImplementation(IInsightExpenseBudgetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> budgets, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseBudget(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, budgets, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="budgets"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseBudget(ref bool suppressDefaultLog, IInsightExpenseBudgetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> budgets, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="budgets"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> budgets, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, budgets, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="budgets"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> budgets, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, grouped by budget. This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="budgets">The budgets to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBudgetApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseBudgetApiResponse?> InsightExpenseBudgetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> budgets = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseBudgetAsync(start, end, xTraceId, budgets, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, grouped by budget. This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="budgets">The budgets to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseBudgetApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseBudgetApiResponse> InsightExpenseBudgetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> budgets = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseBudget(budgets, accounts);

                FormatInsightExpenseBudget(ref start, ref end, ref xTraceId, budgets, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/budget"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/budget");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (budgets.IsSet)
                        parseQueryStringLocalVar["budgets[]"] = ClientUtils.ParameterToString(budgets.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseBudgetApiResponse>();
                        InsightExpenseBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/budget", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseBudgetDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, budgets, accounts);

                        Events.ExecuteOnInsightExpenseBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseBudgetDefaultImplementation(e, "/v1/insight/expense/budget", uriBuilderLocalVar.Path, start, end, xTraceId, budgets, accounts);
                Events.ExecuteOnErrorInsightExpenseBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseBudgetApiResponse"/>
        /// </summary>
        public partial class InsightExpenseBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseBudgetApiResponse(ILogger<InsightExpenseBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseBudgetApiResponse(ILogger<InsightExpenseBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseCategory(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseCategory(Option<List<long>> categories, Option<List<long>> accounts)
        {
            if (categories.IsSet && categories.Value == null)
                throw new ArgumentNullException(nameof(categories));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseCategoryDefaultImplementation(IInsightExpenseCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseCategory(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, categories, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseCategory(ref bool suppressDefaultLog, IInsightExpenseCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseCategoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseCategory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, categories, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseCategory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, grouped by category. This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseCategoryApiResponse?> InsightExpenseCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseCategoryAsync(start, end, xTraceId, categories, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, grouped by category. This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseCategoryApiResponse> InsightExpenseCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseCategory(categories, accounts);

                FormatInsightExpenseCategory(ref start, ref end, ref xTraceId, categories, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/category"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/category");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (categories.IsSet)
                        parseQueryStringLocalVar["categories[]"] = ClientUtils.ParameterToString(categories.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseCategoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseCategoryApiResponse>();
                        InsightExpenseCategoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/category", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseCategoryDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, categories, accounts);

                        Events.ExecuteOnInsightExpenseCategory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseCategoryDefaultImplementation(e, "/v1/insight/expense/category", uriBuilderLocalVar.Path, start, end, xTraceId, categories, accounts);
                Events.ExecuteOnErrorInsightExpenseCategory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseCategoryApiResponse"/>
        /// </summary>
        public partial class InsightExpenseCategoryApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseCategoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseCategoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseCategoryApiResponse(ILogger<InsightExpenseCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseCategoryApiResponse(ILogger<InsightExpenseCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseExpense(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseExpense(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseExpenseDefaultImplementation(IInsightExpenseExpenseApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseExpense(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseExpense(ref bool suppressDefaultLog, IInsightExpenseExpenseApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseExpenseDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseExpense(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseExpense(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, grouped by expense account. This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of expense accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseExpenseApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseExpenseApiResponse?> InsightExpenseExpenseOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseExpenseAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, grouped by expense account. This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of expense accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseExpenseApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseExpenseApiResponse> InsightExpenseExpenseAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseExpense(accounts);

                FormatInsightExpenseExpense(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/expense"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/expense");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseExpenseApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseExpenseApiResponse>();
                        InsightExpenseExpenseApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/expense", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseExpenseDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseExpense(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseExpenseDefaultImplementation(e, "/v1/insight/expense/expense", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseExpense(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseExpenseApiResponse"/>
        /// </summary>
        public partial class InsightExpenseExpenseApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseExpenseApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseExpenseApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseExpenseApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseExpenseApiResponse(ILogger<InsightExpenseExpenseApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseExpenseApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseExpenseApiResponse(ILogger<InsightExpenseExpenseApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseNoBill(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseNoBill(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseNoBillDefaultImplementation(IInsightExpenseNoBillApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseNoBill(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseNoBill(ref bool suppressDefaultLog, IInsightExpenseNoBillApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseNoBillDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseNoBill(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseNoBill(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, without bill. This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBillApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoBillApiResponse?> InsightExpenseNoBillOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseNoBillAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, without bill. This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBillApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoBillApiResponse> InsightExpenseNoBillAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseNoBill(accounts);

                FormatInsightExpenseNoBill(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/no-bill"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/no-bill");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseNoBillApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseNoBillApiResponse>();
                        InsightExpenseNoBillApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/no-bill", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseNoBillDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseNoBill(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseNoBillDefaultImplementation(e, "/v1/insight/expense/no-bill", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseNoBill(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseNoBillApiResponse"/>
        /// </summary>
        public partial class InsightExpenseNoBillApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseNoBillApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseNoBillApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseNoBillApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoBillApiResponse(ILogger<InsightExpenseNoBillApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseNoBillApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoBillApiResponse(ILogger<InsightExpenseNoBillApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseNoBudget(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseNoBudget(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseNoBudgetDefaultImplementation(IInsightExpenseNoBudgetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseNoBudget(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseNoBudget(ref bool suppressDefaultLog, IInsightExpenseNoBudgetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseNoBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseNoBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseNoBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, without budget. This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBudgetApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoBudgetApiResponse?> InsightExpenseNoBudgetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseNoBudgetAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, without budget. This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoBudgetApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoBudgetApiResponse> InsightExpenseNoBudgetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseNoBudget(accounts);

                FormatInsightExpenseNoBudget(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/no-budget"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/no-budget");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseNoBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseNoBudgetApiResponse>();
                        InsightExpenseNoBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/no-budget", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseNoBudgetDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseNoBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseNoBudgetDefaultImplementation(e, "/v1/insight/expense/no-budget", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseNoBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseNoBudgetApiResponse"/>
        /// </summary>
        public partial class InsightExpenseNoBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseNoBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseNoBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseNoBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoBudgetApiResponse(ILogger<InsightExpenseNoBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseNoBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoBudgetApiResponse(ILogger<InsightExpenseNoBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseNoCategory(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseNoCategory(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseNoCategoryDefaultImplementation(IInsightExpenseNoCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseNoCategory(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseNoCategory(ref bool suppressDefaultLog, IInsightExpenseNoCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseNoCategoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseNoCategory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseNoCategory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, without category. This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoCategoryApiResponse?> InsightExpenseNoCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseNoCategoryAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, without category. This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoCategoryApiResponse> InsightExpenseNoCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseNoCategory(accounts);

                FormatInsightExpenseNoCategory(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/no-category"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/no-category");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseNoCategoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseNoCategoryApiResponse>();
                        InsightExpenseNoCategoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/no-category", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseNoCategoryDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseNoCategory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseNoCategoryDefaultImplementation(e, "/v1/insight/expense/no-category", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseNoCategory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseNoCategoryApiResponse"/>
        /// </summary>
        public partial class InsightExpenseNoCategoryApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseNoCategoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseNoCategoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseNoCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoCategoryApiResponse(ILogger<InsightExpenseNoCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseNoCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoCategoryApiResponse(ILogger<InsightExpenseNoCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseNoTag(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseNoTag(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseNoTagDefaultImplementation(IInsightExpenseNoTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseNoTag(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseNoTag(ref bool suppressDefaultLog, IInsightExpenseNoTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseNoTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseNoTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseNoTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, without tag. This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoTagApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoTagApiResponse?> InsightExpenseNoTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseNoTagAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, without tag. This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseNoTagApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseNoTagApiResponse> InsightExpenseNoTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseNoTag(accounts);

                FormatInsightExpenseNoTag(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/no-tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/no-tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseNoTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseNoTagApiResponse>();
                        InsightExpenseNoTagApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/no-tag", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseNoTagDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseNoTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseNoTagDefaultImplementation(e, "/v1/insight/expense/no-tag", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseNoTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseNoTagApiResponse"/>
        /// </summary>
        public partial class InsightExpenseNoTagApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseNoTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseNoTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseNoTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoTagApiResponse(ILogger<InsightExpenseNoTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseNoTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseNoTagApiResponse(ILogger<InsightExpenseNoTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseTag(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseTag(Option<List<long>> tags, Option<List<long>> accounts)
        {
            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseTagDefaultImplementation(IInsightExpenseTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseTag(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, tags, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseTag(ref bool suppressDefaultLog, IInsightExpenseTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, tags, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, grouped by tag. This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTagApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseTagApiResponse?> InsightExpenseTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseTagAsync(start, end, xTraceId, tags, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, grouped by tag. This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTagApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseTagApiResponse> InsightExpenseTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseTag(tags, accounts);

                FormatInsightExpenseTag(ref start, ref end, ref xTraceId, tags, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags[]"] = ClientUtils.ParameterToString(tags.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseTagApiResponse>();
                        InsightExpenseTagApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/tag", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseTagDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, tags, accounts);

                        Events.ExecuteOnInsightExpenseTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseTagDefaultImplementation(e, "/v1/insight/expense/tag", uriBuilderLocalVar.Path, start, end, xTraceId, tags, accounts);
                Events.ExecuteOnErrorInsightExpenseTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseTagApiResponse"/>
        /// </summary>
        public partial class InsightExpenseTagApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseTagApiResponse(ILogger<InsightExpenseTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseTagApiResponse(ILogger<InsightExpenseTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightExpenseTotal(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightExpenseTotal(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightExpenseTotalDefaultImplementation(IInsightExpenseTotalApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightExpenseTotal(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightExpenseTotal(ref bool suppressDefaultLog, IInsightExpenseTotalApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightExpenseTotalDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightExpenseTotal(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightExpenseTotal(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into total expenses. This endpoint gives a sum of the total expenses made by the user. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTotalApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseTotalApiResponse?> InsightExpenseTotalOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightExpenseTotalAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into total expenses. This endpoint gives a sum of the total expenses made by the user. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightExpenseTotalApiResponse"/>&gt;</returns>
        public async Task<IInsightExpenseTotalApiResponse> InsightExpenseTotalAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightExpenseTotal(accounts);

                FormatInsightExpenseTotal(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/expense/total"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/expense/total");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightExpenseTotalApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightExpenseTotalApiResponse>();
                        InsightExpenseTotalApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/expense/total", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightExpenseTotalDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightExpenseTotal(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightExpenseTotalDefaultImplementation(e, "/v1/insight/expense/total", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightExpenseTotal(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightExpenseTotalApiResponse"/>
        /// </summary>
        public partial class InsightExpenseTotalApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightExpenseTotalApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightExpenseTotalApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightExpenseTotalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseTotalApiResponse(ILogger<InsightExpenseTotalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightExpenseTotalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightExpenseTotalApiResponse(ILogger<InsightExpenseTotalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeAsset(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeAsset(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeAssetDefaultImplementation(IInsightIncomeAssetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeAsset(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeAsset(ref bool suppressDefaultLog, IInsightIncomeAssetApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeAssetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeAsset(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeAsset(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into income, grouped by asset account. This endpoint gives a summary of the income received by the user, grouped by asset account. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeAssetApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeAssetApiResponse?> InsightIncomeAssetOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeAssetAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into income, grouped by asset account. This endpoint gives a summary of the income received by the user, grouped by asset account. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeAssetApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeAssetApiResponse> InsightIncomeAssetAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeAsset(accounts);

                FormatInsightIncomeAsset(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/asset"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/asset");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeAssetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeAssetApiResponse>();
                        InsightIncomeAssetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/asset", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeAssetDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightIncomeAsset(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeAssetDefaultImplementation(e, "/v1/insight/income/asset", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightIncomeAsset(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeAssetApiResponse"/>
        /// </summary>
        public partial class InsightIncomeAssetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeAssetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeAssetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeAssetApiResponse(ILogger<InsightIncomeAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeAssetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeAssetApiResponse(ILogger<InsightIncomeAssetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeCategory(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeCategory(Option<List<long>> categories, Option<List<long>> accounts)
        {
            if (categories.IsSet && categories.Value == null)
                throw new ArgumentNullException(nameof(categories));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeCategoryDefaultImplementation(IInsightIncomeCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeCategory(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, categories, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeCategory(ref bool suppressDefaultLog, IInsightIncomeCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeCategoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeCategory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, categories, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeCategory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Insight into income, grouped by category. This endpoint gives a summary of the income received by the user, grouped by (any) category. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeCategoryApiResponse?> InsightIncomeCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeCategoryAsync(start, end, xTraceId, categories, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into income, grouped by category. This endpoint gives a summary of the income received by the user, grouped by (any) category. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeCategoryApiResponse> InsightIncomeCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeCategory(categories, accounts);

                FormatInsightIncomeCategory(ref start, ref end, ref xTraceId, categories, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/category"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/category");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (categories.IsSet)
                        parseQueryStringLocalVar["categories[]"] = ClientUtils.ParameterToString(categories.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeCategoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeCategoryApiResponse>();
                        InsightIncomeCategoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/category", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeCategoryDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, categories, accounts);

                        Events.ExecuteOnInsightIncomeCategory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeCategoryDefaultImplementation(e, "/v1/insight/income/category", uriBuilderLocalVar.Path, start, end, xTraceId, categories, accounts);
                Events.ExecuteOnErrorInsightIncomeCategory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeCategoryApiResponse"/>
        /// </summary>
        public partial class InsightIncomeCategoryApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeCategoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeCategoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeCategoryApiResponse(ILogger<InsightIncomeCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeCategoryApiResponse(ILogger<InsightIncomeCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeNoCategory(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeNoCategory(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeNoCategoryDefaultImplementation(IInsightIncomeNoCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeNoCategory(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeNoCategory(ref bool suppressDefaultLog, IInsightIncomeNoCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeNoCategoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeNoCategory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeNoCategory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into income, without category. This endpoint gives a summary of the income received by the user, including only income with no category. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeNoCategoryApiResponse?> InsightIncomeNoCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeNoCategoryAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into income, without category. This endpoint gives a summary of the income received by the user, including only income with no category. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeNoCategoryApiResponse> InsightIncomeNoCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeNoCategory(accounts);

                FormatInsightIncomeNoCategory(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/no-category"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/no-category");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeNoCategoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeNoCategoryApiResponse>();
                        InsightIncomeNoCategoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/no-category", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeNoCategoryDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightIncomeNoCategory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeNoCategoryDefaultImplementation(e, "/v1/insight/income/no-category", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightIncomeNoCategory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeNoCategoryApiResponse"/>
        /// </summary>
        public partial class InsightIncomeNoCategoryApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeNoCategoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeNoCategoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeNoCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeNoCategoryApiResponse(ILogger<InsightIncomeNoCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeNoCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeNoCategoryApiResponse(ILogger<InsightIncomeNoCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeNoTag(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeNoTag(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeNoTagDefaultImplementation(IInsightIncomeNoTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeNoTag(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeNoTag(ref bool suppressDefaultLog, IInsightIncomeNoTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeNoTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeNoTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeNoTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into income, without tag. This endpoint gives a summary of the income received by the user, including only income with no tag. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoTagApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeNoTagApiResponse?> InsightIncomeNoTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeNoTagAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into income, without tag. This endpoint gives a summary of the income received by the user, including only income with no tag. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeNoTagApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeNoTagApiResponse> InsightIncomeNoTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeNoTag(accounts);

                FormatInsightIncomeNoTag(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/no-tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/no-tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeNoTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeNoTagApiResponse>();
                        InsightIncomeNoTagApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/no-tag", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeNoTagDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightIncomeNoTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeNoTagDefaultImplementation(e, "/v1/insight/income/no-tag", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightIncomeNoTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeNoTagApiResponse"/>
        /// </summary>
        public partial class InsightIncomeNoTagApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeNoTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeNoTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeNoTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeNoTagApiResponse(ILogger<InsightIncomeNoTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeNoTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeNoTagApiResponse(ILogger<InsightIncomeNoTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeRevenue(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeRevenue(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeRevenueDefaultImplementation(IInsightIncomeRevenueApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeRevenue(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeRevenue(ref bool suppressDefaultLog, IInsightIncomeRevenueApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeRevenueDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeRevenue(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeRevenue(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into income, grouped by revenue account. This endpoint gives a summary of the income received by the user, grouped by revenue account. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of revenue accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeRevenueApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeRevenueApiResponse?> InsightIncomeRevenueOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeRevenueAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into income, grouped by revenue account. This endpoint gives a summary of the income received by the user, grouped by revenue account. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you add the accounts ID&#39;s of revenue accounts, only those accounts are included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID&#39;s. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeRevenueApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeRevenueApiResponse> InsightIncomeRevenueAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeRevenue(accounts);

                FormatInsightIncomeRevenue(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/revenue"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/revenue");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeRevenueApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeRevenueApiResponse>();
                        InsightIncomeRevenueApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/revenue", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeRevenueDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightIncomeRevenue(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeRevenueDefaultImplementation(e, "/v1/insight/income/revenue", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightIncomeRevenue(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeRevenueApiResponse"/>
        /// </summary>
        public partial class InsightIncomeRevenueApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeRevenueApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeRevenueApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeRevenueApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeRevenueApiResponse(ILogger<InsightIncomeRevenueApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeRevenueApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeRevenueApiResponse(ILogger<InsightIncomeRevenueApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeTag(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeTag(Option<List<long>> tags, Option<List<long>> accounts)
        {
            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeTagDefaultImplementation(IInsightIncomeTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeTag(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, tags, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeTag(ref bool suppressDefaultLog, IInsightIncomeTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, tags, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Insight into income, grouped by tag. This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTagApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeTagApiResponse?> InsightIncomeTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeTagAsync(start, end, xTraceId, tags, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into income, grouped by tag. This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTagApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeTagApiResponse> InsightIncomeTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeTag(tags, accounts);

                FormatInsightIncomeTag(ref start, ref end, ref xTraceId, tags, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags[]"] = ClientUtils.ParameterToString(tags.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeTagApiResponse>();
                        InsightIncomeTagApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/tag", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeTagDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, tags, accounts);

                        Events.ExecuteOnInsightIncomeTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeTagDefaultImplementation(e, "/v1/insight/income/tag", uriBuilderLocalVar.Path, start, end, xTraceId, tags, accounts);
                Events.ExecuteOnErrorInsightIncomeTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeTagApiResponse"/>
        /// </summary>
        public partial class InsightIncomeTagApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeTagApiResponse(ILogger<InsightIncomeTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeTagApiResponse(ILogger<InsightIncomeTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightIncomeTotal(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightIncomeTotal(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightIncomeTotalDefaultImplementation(IInsightIncomeTotalApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightIncomeTotal(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightIncomeTotal(ref bool suppressDefaultLog, IInsightIncomeTotalApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightIncomeTotalDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightIncomeTotal(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightIncomeTotal(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into total income. This endpoint gives a sum of the total income received by the user. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTotalApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeTotalApiResponse?> InsightIncomeTotalOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightIncomeTotalAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into total income. This endpoint gives a sum of the total income received by the user. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightIncomeTotalApiResponse"/>&gt;</returns>
        public async Task<IInsightIncomeTotalApiResponse> InsightIncomeTotalAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightIncomeTotal(accounts);

                FormatInsightIncomeTotal(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/income/total"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/income/total");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightIncomeTotalApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightIncomeTotalApiResponse>();
                        InsightIncomeTotalApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/income/total", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightIncomeTotalDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightIncomeTotal(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightIncomeTotalDefaultImplementation(e, "/v1/insight/income/total", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightIncomeTotal(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightIncomeTotalApiResponse"/>
        /// </summary>
        public partial class InsightIncomeTotalApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightIncomeTotalApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightIncomeTotalApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightIncomeTotalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeTotalApiResponse(ILogger<InsightIncomeTotalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightIncomeTotalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightIncomeTotalApiResponse(ILogger<InsightIncomeTotalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightTransferCategory(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightTransferCategory(Option<List<long>> categories, Option<List<long>> accounts)
        {
            if (categories.IsSet && categories.Value == null)
                throw new ArgumentNullException(nameof(categories));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        private void AfterInsightTransferCategoryDefaultImplementation(IInsightTransferCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightTransferCategory(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, categories, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightTransferCategory(ref bool suppressDefaultLog, IInsightTransferCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightTransferCategoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightTransferCategory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, categories, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="categories"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightTransferCategory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> categories, Option<List<long>> accounts);

        /// <summary>
        /// Insight into transfers, grouped by category. This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferCategoryApiResponse?> InsightTransferCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightTransferCategoryAsync(start, end, xTraceId, categories, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into transfers, grouped by category. This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="categories">The categories to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferCategoryApiResponse> InsightTransferCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> categories = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightTransferCategory(categories, accounts);

                FormatInsightTransferCategory(ref start, ref end, ref xTraceId, categories, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/transfer/category"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/transfer/category");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (categories.IsSet)
                        parseQueryStringLocalVar["categories[]"] = ClientUtils.ParameterToString(categories.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightTransferCategoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightTransferCategoryApiResponse>();
                        InsightTransferCategoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/transfer/category", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightTransferCategoryDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, categories, accounts);

                        Events.ExecuteOnInsightTransferCategory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightTransferCategoryDefaultImplementation(e, "/v1/insight/transfer/category", uriBuilderLocalVar.Path, start, end, xTraceId, categories, accounts);
                Events.ExecuteOnErrorInsightTransferCategory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightTransferCategoryApiResponse"/>
        /// </summary>
        public partial class InsightTransferCategoryApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightTransferCategoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightTransferCategoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightTransferCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferCategoryApiResponse(ILogger<InsightTransferCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightTransferCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferCategoryApiResponse(ILogger<InsightTransferCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightTransferNoCategory(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightTransferNoCategory(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightTransferNoCategoryDefaultImplementation(IInsightTransferNoCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightTransferNoCategory(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightTransferNoCategory(ref bool suppressDefaultLog, IInsightTransferNoCategoryApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightTransferNoCategoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightTransferNoCategory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightTransferNoCategory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into transfers, without category. This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferNoCategoryApiResponse?> InsightTransferNoCategoryOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightTransferNoCategoryAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into transfers, without category. This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoCategoryApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferNoCategoryApiResponse> InsightTransferNoCategoryAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightTransferNoCategory(accounts);

                FormatInsightTransferNoCategory(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/transfer/no-category"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/transfer/no-category");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightTransferNoCategoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightTransferNoCategoryApiResponse>();
                        InsightTransferNoCategoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/transfer/no-category", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightTransferNoCategoryDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightTransferNoCategory(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightTransferNoCategoryDefaultImplementation(e, "/v1/insight/transfer/no-category", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightTransferNoCategory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightTransferNoCategoryApiResponse"/>
        /// </summary>
        public partial class InsightTransferNoCategoryApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightTransferNoCategoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightTransferNoCategoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightTransferNoCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferNoCategoryApiResponse(ILogger<InsightTransferNoCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightTransferNoCategoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferNoCategoryApiResponse(ILogger<InsightTransferNoCategoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightTransferNoTag(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightTransferNoTag(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightTransferNoTagDefaultImplementation(IInsightTransferNoTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightTransferNoTag(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightTransferNoTag(ref bool suppressDefaultLog, IInsightTransferNoTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightTransferNoTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightTransferNoTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightTransferNoTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into expenses, without tag. This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoTagApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferNoTagApiResponse?> InsightTransferNoTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightTransferNoTagAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into expenses, without tag. This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferNoTagApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferNoTagApiResponse> InsightTransferNoTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightTransferNoTag(accounts);

                FormatInsightTransferNoTag(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/transfer/no-tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/transfer/no-tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightTransferNoTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightTransferNoTagApiResponse>();
                        InsightTransferNoTagApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/transfer/no-tag", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightTransferNoTagDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightTransferNoTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightTransferNoTagDefaultImplementation(e, "/v1/insight/transfer/no-tag", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightTransferNoTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightTransferNoTagApiResponse"/>
        /// </summary>
        public partial class InsightTransferNoTagApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightTransferNoTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightTransferNoTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightTransferNoTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferNoTagApiResponse(ILogger<InsightTransferNoTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightTransferNoTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferNoTagApiResponse(ILogger<InsightTransferNoTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightTransferTag(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightTransferTag(Option<List<long>> tags, Option<List<long>> accounts)
        {
            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags));

            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        private void AfterInsightTransferTagDefaultImplementation(IInsightTransferTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightTransferTag(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, tags, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightTransferTag(ref bool suppressDefaultLog, IInsightTransferTagApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightTransferTagDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightTransferTag(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, tags, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="tags"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightTransferTag(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> tags, Option<List<long>> accounts);

        /// <summary>
        /// Insight into transfers, grouped by tag. This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTagApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferTagApiResponse?> InsightTransferTagOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightTransferTagAsync(start, end, xTraceId, tags, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into transfers, grouped by tag. This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="tags">The tags to be included in the results.  (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTagApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferTagApiResponse> InsightTransferTagAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> tags = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightTransferTag(tags, accounts);

                FormatInsightTransferTag(ref start, ref end, ref xTraceId, tags, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/transfer/tag"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/transfer/tag");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (tags.IsSet)
                        parseQueryStringLocalVar["tags[]"] = ClientUtils.ParameterToString(tags.Value);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightTransferTagApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightTransferTagApiResponse>();
                        InsightTransferTagApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/transfer/tag", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightTransferTagDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, tags, accounts);

                        Events.ExecuteOnInsightTransferTag(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightTransferTagDefaultImplementation(e, "/v1/insight/transfer/tag", uriBuilderLocalVar.Path, start, end, xTraceId, tags, accounts);
                Events.ExecuteOnErrorInsightTransferTag(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightTransferTagApiResponse"/>
        /// </summary>
        public partial class InsightTransferTagApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightTransferTagApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightTransferTagApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightTransferTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferTagApiResponse(ILogger<InsightTransferTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightTransferTagApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferTagApiResponse(ILogger<InsightTransferTagApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightGroupEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightGroupEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightGroupEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightTransferTotal(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightTransferTotal(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightTransferTotalDefaultImplementation(IInsightTransferTotalApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightTransferTotal(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightTransferTotal(ref bool suppressDefaultLog, IInsightTransferTotalApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightTransferTotalDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightTransferTotal(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightTransferTotal(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into total transfers. This endpoint gives a sum of the total amount transfers made by the user. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTotalApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferTotalApiResponse?> InsightTransferTotalOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightTransferTotalAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into total transfers. This endpoint gives a sum of the total amount transfers made by the user. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransferTotalApiResponse"/>&gt;</returns>
        public async Task<IInsightTransferTotalApiResponse> InsightTransferTotalAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightTransferTotal(accounts);

                FormatInsightTransferTotal(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/transfer/total"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/transfer/total");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightTransferTotalApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightTransferTotalApiResponse>();
                        InsightTransferTotalApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/transfer/total", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightTransferTotalDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightTransferTotal(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightTransferTotalDefaultImplementation(e, "/v1/insight/transfer/total", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightTransferTotal(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightTransferTotalApiResponse"/>
        /// </summary>
        public partial class InsightTransferTotalApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightTransferTotalApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightTransferTotalApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightTransferTotalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferTotalApiResponse(ILogger<InsightTransferTotalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightTransferTotalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransferTotalApiResponse(ILogger<InsightTransferTotalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTotalEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTotalEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTotalEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatInsightTransfers(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accounts"></param>
        /// <returns></returns>
        private void ValidateInsightTransfers(Option<List<long>> accounts)
        {
            if (accounts.IsSet && accounts.Value == null)
                throw new ArgumentNullException(nameof(accounts));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void AfterInsightTransfersDefaultImplementation(IInsightTransfersApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLog = false;
            AfterInsightTransfers(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void AfterInsightTransfers(ref bool suppressDefaultLog, IInsightTransfersApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        private void OnErrorInsightTransfersDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorInsightTransfers(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId, accounts);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        /// <param name="accounts"></param>
        partial void OnErrorInsightTransfers(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId, Option<List<long>> accounts);

        /// <summary>
        /// Insight into transfers, grouped by account. This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransfersApiResponse"/>&gt;</returns>
        public async Task<IInsightTransfersApiResponse?> InsightTransfersOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await InsightTransfersAsync(start, end, xTraceId, accounts, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Insight into transfers, grouped by account. This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="accounts">The accounts to be included in the results. If you include ID&#39;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#39;s will be ignored.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IInsightTransfersApiResponse"/>&gt;</returns>
        public async Task<IInsightTransfersApiResponse> InsightTransfersAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, Option<List<long>> accounts = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateInsightTransfers(accounts);

                FormatInsightTransfers(ref start, ref end, ref xTraceId, accounts);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/insight/transfer/asset"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/insight/transfer/asset");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (accounts.IsSet)
                        parseQueryStringLocalVar["accounts[]"] = ClientUtils.ParameterToString(accounts.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<InsightTransfersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<InsightTransfersApiResponse>();
                        InsightTransfersApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/insight/transfer/asset", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterInsightTransfersDefaultImplementation(apiResponseLocalVar, start, end, xTraceId, accounts);

                        Events.ExecuteOnInsightTransfers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorInsightTransfersDefaultImplementation(e, "/v1/insight/transfer/asset", uriBuilderLocalVar.Path, start, end, xTraceId, accounts);
                Events.ExecuteOnErrorInsightTransfers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="InsightTransfersApiResponse"/>
        /// </summary>
        public partial class InsightTransfersApiResponse : Brotal.FireflyIII.Client.ApiResponse, IInsightTransfersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<InsightTransfersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="InsightTransfersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransfersApiResponse(ILogger<InsightTransfersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="InsightTransfersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public InsightTransfersApiResponse(ILogger<InsightTransfersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<InsightTransferEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<InsightTransferEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<InsightTransferEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
