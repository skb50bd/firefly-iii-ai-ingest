// <auto-generated>
/*
 * Firefly III API v6.3.0
 *
 * This is the documentation of the Firefly III API. Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. <br><br> Please keep in mind that the demo site does **not** accept requests from `curl`, `colly`, `wget`, etc. You must use a browser or a tool like Insomnia to make your test requests. <br><br> To learn more about the idiosyncrasies of this API, please read about the API in the [Firefly III API documentation](https://docs.firefly-iii.org/references/firefly-iii/api/). <br><br> <small>This file was last generated on 2025-08-16 @ 20:21:49 (Europe/Amsterdam)</small> 
 *
 * The version of the OpenAPI document: v6.3.0
 * Contact: james@firefly-iii.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Brotal.FireflyIII.Client;
using Brotal.FireflyIII.Model;
using System.Diagnostics.CodeAnalysis;

namespace Brotal.FireflyIII.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ICurrencyExchangeRatesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        CurrencyExchangeRatesApiEvents Events { get; }

        /// <summary>
        /// Delete a specific currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Delete a specific currency exchange rate by its internal ID.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateApiResponse"/>&gt;</returns>
        Task<IDeleteSpecificCurrencyExchangeRateApiResponse> DeleteSpecificCurrencyExchangeRateAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a specific currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Delete a specific currency exchange rate by its internal ID.
        /// </remarks>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateApiResponse"/>?&gt;</returns>
        Task<IDeleteSpecificCurrencyExchangeRateApiResponse?> DeleteSpecificCurrencyExchangeRateOrDefaultAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date.
        /// </summary>
        /// <remarks>
        /// Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date.  It&#39;s important to know that the reverse exchange rate (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>&gt;</returns>
        Task<IDeleteSpecificCurrencyExchangeRateOnDateApiResponse> DeleteSpecificCurrencyExchangeRateOnDateAsync(string from, string to, string date, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date.
        /// </summary>
        /// <remarks>
        /// Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date.  It&#39;s important to know that the reverse exchange rate (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </remarks>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>?&gt;</returns>
        Task<IDeleteSpecificCurrencyExchangeRateOnDateApiResponse?> DeleteSpecificCurrencyExchangeRateOnDateOrDefaultAsync(string from, string to, string date, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;.
        /// </summary>
        /// <remarks>
        /// Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;. It&#39;s important to know that the reverse exchange rates (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        Task<IDeleteSpecificCurrencyExchangeRatesApiResponse> DeleteSpecificCurrencyExchangeRatesAsync(string from, string to, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;.
        /// </summary>
        /// <remarks>
        /// Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;. It&#39;s important to know that the reverse exchange rates (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </remarks>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRatesApiResponse"/>?&gt;</returns>
        Task<IDeleteSpecificCurrencyExchangeRatesApiResponse?> DeleteSpecificCurrencyExchangeRatesOrDefaultAsync(string from, string to, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchange rates that Firefly III knows.
        /// </summary>
        /// <remarks>
        /// List exchange rates that Firefly III knows.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        Task<IListCurrencyExchangeRatesApiResponse> ListCurrencyExchangeRatesAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchange rates that Firefly III knows.
        /// </summary>
        /// <remarks>
        /// List exchange rates that Firefly III knows.
        /// </remarks>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCurrencyExchangeRatesApiResponse"/>?&gt;</returns>
        Task<IListCurrencyExchangeRatesApiResponse?> ListCurrencyExchangeRatesOrDefaultAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List a single specific exchange rate.
        /// </summary>
        /// <remarks>
        /// List a single specific exchange rate by its ID.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateApiResponse"/>&gt;</returns>
        Task<IListSpecificCurrencyExchangeRateApiResponse> ListSpecificCurrencyExchangeRateAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List a single specific exchange rate.
        /// </summary>
        /// <remarks>
        /// List a single specific exchange rate by its ID.
        /// </remarks>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateApiResponse"/>?&gt;</returns>
        Task<IListSpecificCurrencyExchangeRateApiResponse?> ListSpecificCurrencyExchangeRateOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List the exchange rate for the from and to-currency on the requested date.
        /// </summary>
        /// <remarks>
        /// List the exchange rate for the from and to-currency on the requested date.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateOnDateApiResponse"/>&gt;</returns>
        Task<IListSpecificCurrencyExchangeRateOnDateApiResponse> ListSpecificCurrencyExchangeRateOnDateAsync(string from, string to, string date, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List the exchange rate for the from and to-currency on the requested date.
        /// </summary>
        /// <remarks>
        /// List the exchange rate for the from and to-currency on the requested date.
        /// </remarks>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateOnDateApiResponse"/>?&gt;</returns>
        Task<IListSpecificCurrencyExchangeRateOnDateApiResponse?> ListSpecificCurrencyExchangeRateOnDateOrDefaultAsync(string from, string to, string date, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchange rates from/to the mentioned currencies.
        /// </summary>
        /// <remarks>
        /// List all exchange rates from/to the mentioned currencies.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        Task<IListSpecificCurrencyExchangeRatesApiResponse> ListSpecificCurrencyExchangeRatesAsync(string from, string to, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all exchange rates from/to the mentioned currencies.
        /// </summary>
        /// <remarks>
        /// List all exchange rates from/to the mentioned currencies.
        /// </remarks>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRatesApiResponse"/>?&gt;</returns>
        Task<IListSpecificCurrencyExchangeRatesApiResponse?> ListSpecificCurrencyExchangeRatesOrDefaultAsync(string from, string to, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store a new currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyExchangeRateStore">JSON array or key&#x3D;value pairs with the necessary exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRateApiResponse"/>&gt;</returns>
        Task<IStoreCurrencyExchangeRateApiResponse> StoreCurrencyExchangeRateAsync(CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store a new currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
        /// </remarks>
        /// <param name="currencyExchangeRateStore">JSON array or key&#x3D;value pairs with the necessary exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRateApiResponse"/>?&gt;</returns>
        Task<IStoreCurrencyExchangeRateApiResponse?> StoreCurrencyExchangeRateOrDefaultAsync(CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store new currency exchange rates under this date
        /// </summary>
        /// <remarks>
        /// Stores a new set of exchange rates. The date is fixed (in the URL parameter) and the data required can be submitted as a JSON body.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByDateApiResponse"/>&gt;</returns>
        Task<IStoreCurrencyExchangeRatesByDateApiResponse> StoreCurrencyExchangeRatesByDateAsync(string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store new currency exchange rates under this date
        /// </summary>
        /// <remarks>
        /// Stores a new set of exchange rates. The date is fixed (in the URL parameter) and the data required can be submitted as a JSON body.
        /// </remarks>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByDateApiResponse"/>?&gt;</returns>
        Task<IStoreCurrencyExchangeRatesByDateApiResponse?> StoreCurrencyExchangeRatesByDateOrDefaultAsync(string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store new currency exchange rates under this from/to pair.
        /// </summary>
        /// <remarks>
        /// Stores a new set of exchange rates for this pair. The date is variable, and the data required can be submitted as a JSON body.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="requestBody">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByPairApiResponse"/>&gt;</returns>
        Task<IStoreCurrencyExchangeRatesByPairApiResponse> StoreCurrencyExchangeRatesByPairAsync(string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store new currency exchange rates under this from/to pair.
        /// </summary>
        /// <remarks>
        /// Stores a new set of exchange rates for this pair. The date is variable, and the data required can be submitted as a JSON body.
        /// </remarks>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="requestBody">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByPairApiResponse"/>?&gt;</returns>
        Task<IStoreCurrencyExchangeRatesByPairApiResponse?> StoreCurrencyExchangeRatesByPairOrDefaultAsync(string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Used to update a single currency exchange rate by its ID. Including the from/to currency is optional. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the currency exchange rate.</param>
        /// <param name="currencyExchangeRateUpdate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateApiResponse"/>&gt;</returns>
        Task<IUpdateCurrencyExchangeRateApiResponse> UpdateCurrencyExchangeRateAsync(string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Used to update a single currency exchange rate by its ID. Including the from/to currency is optional. 
        /// </remarks>
        /// <param name="id">The ID of the currency exchange rate.</param>
        /// <param name="currencyExchangeRateUpdate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateApiResponse"/>?&gt;</returns>
        Task<IUpdateCurrencyExchangeRateApiResponse?> UpdateCurrencyExchangeRateOrDefaultAsync(string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Used to update a single currency exchange rate by its currency codes and date 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateByDateApiResponse"/>&gt;</returns>
        Task<IUpdateCurrencyExchangeRateByDateApiResponse> UpdateCurrencyExchangeRateByDateAsync(string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing currency exchange rate.
        /// </summary>
        /// <remarks>
        /// Used to update a single currency exchange rate by its currency codes and date 
        /// </remarks>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateByDateApiResponse"/>?&gt;</returns>
        Task<IUpdateCurrencyExchangeRateByDateApiResponse?> UpdateCurrencyExchangeRateByDateOrDefaultAsync(string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IDeleteSpecificCurrencyExchangeRateApiResponse"/>
    /// </summary>
    public interface IDeleteSpecificCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>
    /// </summary>
    public interface IDeleteSpecificCurrencyExchangeRateOnDateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteSpecificCurrencyExchangeRatesApiResponse"/>
    /// </summary>
    public interface IDeleteSpecificCurrencyExchangeRatesApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListCurrencyExchangeRatesApiResponse"/>
    /// </summary>
    public interface IListCurrencyExchangeRatesApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListSpecificCurrencyExchangeRateApiResponse"/>
    /// </summary>
    public interface IListSpecificCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListSpecificCurrencyExchangeRateOnDateApiResponse"/>
    /// </summary>
    public interface IListSpecificCurrencyExchangeRateOnDateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListSpecificCurrencyExchangeRatesApiResponse"/>
    /// </summary>
    public interface IListSpecificCurrencyExchangeRatesApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IStoreCurrencyExchangeRateApiResponse"/>
    /// </summary>
    public interface IStoreCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IStoreCurrencyExchangeRatesByDateApiResponse"/>
    /// </summary>
    public interface IStoreCurrencyExchangeRatesByDateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateArray?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IStoreCurrencyExchangeRatesByPairApiResponse"/>
    /// </summary>
    public interface IStoreCurrencyExchangeRatesByPairApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateArray?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateCurrencyExchangeRateApiResponse"/>
    /// </summary>
    public interface IUpdateCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateCurrencyExchangeRateByDateApiResponse"/>
    /// </summary>
    public interface IUpdateCurrencyExchangeRateByDateApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class CurrencyExchangeRatesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteSpecificCurrencyExchangeRate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteSpecificCurrencyExchangeRate;

        internal void ExecuteOnDeleteSpecificCurrencyExchangeRate(CurrencyExchangeRatesApi.DeleteSpecificCurrencyExchangeRateApiResponse apiResponse)
        {
            OnDeleteSpecificCurrencyExchangeRate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteSpecificCurrencyExchangeRate(Exception exception)
        {
            OnErrorDeleteSpecificCurrencyExchangeRate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteSpecificCurrencyExchangeRateOnDate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteSpecificCurrencyExchangeRateOnDate;

        internal void ExecuteOnDeleteSpecificCurrencyExchangeRateOnDate(CurrencyExchangeRatesApi.DeleteSpecificCurrencyExchangeRateOnDateApiResponse apiResponse)
        {
            OnDeleteSpecificCurrencyExchangeRateOnDate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteSpecificCurrencyExchangeRateOnDate(Exception exception)
        {
            OnErrorDeleteSpecificCurrencyExchangeRateOnDate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteSpecificCurrencyExchangeRates;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteSpecificCurrencyExchangeRates;

        internal void ExecuteOnDeleteSpecificCurrencyExchangeRates(CurrencyExchangeRatesApi.DeleteSpecificCurrencyExchangeRatesApiResponse apiResponse)
        {
            OnDeleteSpecificCurrencyExchangeRates?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteSpecificCurrencyExchangeRates(Exception exception)
        {
            OnErrorDeleteSpecificCurrencyExchangeRates?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListCurrencyExchangeRates;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListCurrencyExchangeRates;

        internal void ExecuteOnListCurrencyExchangeRates(CurrencyExchangeRatesApi.ListCurrencyExchangeRatesApiResponse apiResponse)
        {
            OnListCurrencyExchangeRates?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListCurrencyExchangeRates(Exception exception)
        {
            OnErrorListCurrencyExchangeRates?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListSpecificCurrencyExchangeRate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListSpecificCurrencyExchangeRate;

        internal void ExecuteOnListSpecificCurrencyExchangeRate(CurrencyExchangeRatesApi.ListSpecificCurrencyExchangeRateApiResponse apiResponse)
        {
            OnListSpecificCurrencyExchangeRate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListSpecificCurrencyExchangeRate(Exception exception)
        {
            OnErrorListSpecificCurrencyExchangeRate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListSpecificCurrencyExchangeRateOnDate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListSpecificCurrencyExchangeRateOnDate;

        internal void ExecuteOnListSpecificCurrencyExchangeRateOnDate(CurrencyExchangeRatesApi.ListSpecificCurrencyExchangeRateOnDateApiResponse apiResponse)
        {
            OnListSpecificCurrencyExchangeRateOnDate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListSpecificCurrencyExchangeRateOnDate(Exception exception)
        {
            OnErrorListSpecificCurrencyExchangeRateOnDate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListSpecificCurrencyExchangeRates;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListSpecificCurrencyExchangeRates;

        internal void ExecuteOnListSpecificCurrencyExchangeRates(CurrencyExchangeRatesApi.ListSpecificCurrencyExchangeRatesApiResponse apiResponse)
        {
            OnListSpecificCurrencyExchangeRates?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListSpecificCurrencyExchangeRates(Exception exception)
        {
            OnErrorListSpecificCurrencyExchangeRates?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStoreCurrencyExchangeRate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStoreCurrencyExchangeRate;

        internal void ExecuteOnStoreCurrencyExchangeRate(CurrencyExchangeRatesApi.StoreCurrencyExchangeRateApiResponse apiResponse)
        {
            OnStoreCurrencyExchangeRate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStoreCurrencyExchangeRate(Exception exception)
        {
            OnErrorStoreCurrencyExchangeRate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStoreCurrencyExchangeRatesByDate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStoreCurrencyExchangeRatesByDate;

        internal void ExecuteOnStoreCurrencyExchangeRatesByDate(CurrencyExchangeRatesApi.StoreCurrencyExchangeRatesByDateApiResponse apiResponse)
        {
            OnStoreCurrencyExchangeRatesByDate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStoreCurrencyExchangeRatesByDate(Exception exception)
        {
            OnErrorStoreCurrencyExchangeRatesByDate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStoreCurrencyExchangeRatesByPair;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStoreCurrencyExchangeRatesByPair;

        internal void ExecuteOnStoreCurrencyExchangeRatesByPair(CurrencyExchangeRatesApi.StoreCurrencyExchangeRatesByPairApiResponse apiResponse)
        {
            OnStoreCurrencyExchangeRatesByPair?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStoreCurrencyExchangeRatesByPair(Exception exception)
        {
            OnErrorStoreCurrencyExchangeRatesByPair?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateCurrencyExchangeRate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateCurrencyExchangeRate;

        internal void ExecuteOnUpdateCurrencyExchangeRate(CurrencyExchangeRatesApi.UpdateCurrencyExchangeRateApiResponse apiResponse)
        {
            OnUpdateCurrencyExchangeRate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateCurrencyExchangeRate(Exception exception)
        {
            OnErrorUpdateCurrencyExchangeRate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateCurrencyExchangeRateByDate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateCurrencyExchangeRateByDate;

        internal void ExecuteOnUpdateCurrencyExchangeRateByDate(CurrencyExchangeRatesApi.UpdateCurrencyExchangeRateByDateApiResponse apiResponse)
        {
            OnUpdateCurrencyExchangeRateByDate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateCurrencyExchangeRateByDate(Exception exception)
        {
            OnErrorUpdateCurrencyExchangeRateByDate?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class CurrencyExchangeRatesApi : ICurrencyExchangeRatesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<CurrencyExchangeRatesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public CurrencyExchangeRatesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrencyExchangeRatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CurrencyExchangeRatesApi(ILogger<CurrencyExchangeRatesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, CurrencyExchangeRatesApiEvents currencyExchangeRatesApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<CurrencyExchangeRatesApi>();
            HttpClient = httpClient;
            Events = currencyExchangeRatesApiEvents;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatDeleteSpecificCurrencyExchangeRate(ref string id, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteSpecificCurrencyExchangeRate(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        private void AfterDeleteSpecificCurrencyExchangeRateDefaultImplementation(IDeleteSpecificCurrencyExchangeRateApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteSpecificCurrencyExchangeRate(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        partial void AfterDeleteSpecificCurrencyExchangeRate(ref bool suppressDefaultLog, IDeleteSpecificCurrencyExchangeRateApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorDeleteSpecificCurrencyExchangeRateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteSpecificCurrencyExchangeRate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorDeleteSpecificCurrencyExchangeRate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId);

        /// <summary>
        /// Delete a specific currency exchange rate. Delete a specific currency exchange rate by its internal ID.
        /// </summary>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IDeleteSpecificCurrencyExchangeRateApiResponse?> DeleteSpecificCurrencyExchangeRateOrDefaultAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteSpecificCurrencyExchangeRateAsync(id, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a specific currency exchange rate. Delete a specific currency exchange rate by its internal ID.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IDeleteSpecificCurrencyExchangeRateApiResponse> DeleteSpecificCurrencyExchangeRateAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteSpecificCurrencyExchangeRate(id);

                FormatDeleteSpecificCurrencyExchangeRate(ref id, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteSpecificCurrencyExchangeRateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteSpecificCurrencyExchangeRateApiResponse>();
                        DeleteSpecificCurrencyExchangeRateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteSpecificCurrencyExchangeRateDefaultImplementation(apiResponseLocalVar, id, xTraceId);

                        Events.ExecuteOnDeleteSpecificCurrencyExchangeRate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteSpecificCurrencyExchangeRateDefaultImplementation(e, "/v1/exchange-rates/{id}", uriBuilderLocalVar.Path, id, xTraceId);
                Events.ExecuteOnErrorDeleteSpecificCurrencyExchangeRate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteSpecificCurrencyExchangeRateApiResponse"/>
        /// </summary>
        public partial class DeleteSpecificCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IDeleteSpecificCurrencyExchangeRateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteSpecificCurrencyExchangeRateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteSpecificCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSpecificCurrencyExchangeRateApiResponse(ILogger<DeleteSpecificCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteSpecificCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSpecificCurrencyExchangeRateApiResponse(ILogger<DeleteSpecificCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteSpecificCurrencyExchangeRateOnDate(ref string from, ref string to, ref string date, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <returns></returns>
        private void ValidateDeleteSpecificCurrencyExchangeRateOnDate(string from, string to, string date)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));

            if (to == null)
                throw new ArgumentNullException(nameof(to));

            if (date == null)
                throw new ArgumentNullException(nameof(date));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        private void AfterDeleteSpecificCurrencyExchangeRateOnDateDefaultImplementation(IDeleteSpecificCurrencyExchangeRateOnDateApiResponse apiResponseLocalVar, string from, string to, string date, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteSpecificCurrencyExchangeRateOnDate(ref suppressDefaultLog, apiResponseLocalVar, from, to, date, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        partial void AfterDeleteSpecificCurrencyExchangeRateOnDate(ref bool suppressDefaultLog, IDeleteSpecificCurrencyExchangeRateOnDateApiResponse apiResponseLocalVar, string from, string to, string date, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorDeleteSpecificCurrencyExchangeRateOnDateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, string date, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteSpecificCurrencyExchangeRateOnDate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, from, to, date, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorDeleteSpecificCurrencyExchangeRateOnDate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, string date, Option<Guid> xTraceId);

        /// <summary>
        /// Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date. Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date.  It&#39;s important to know that the reverse exchange rate (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </summary>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>&gt;</returns>
        public async Task<IDeleteSpecificCurrencyExchangeRateOnDateApiResponse?> DeleteSpecificCurrencyExchangeRateOnDateOrDefaultAsync(string from, string to, string date, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteSpecificCurrencyExchangeRateOnDateAsync(from, to, date, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date. Delete the currency exchange rate from &#39;from&#39; to &#39;to&#39; on the specified date.  It&#39;s important to know that the reverse exchange rate (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>&gt;</returns>
        public async Task<IDeleteSpecificCurrencyExchangeRateOnDateApiResponse> DeleteSpecificCurrencyExchangeRateOnDateAsync(string from, string to, string date, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteSpecificCurrencyExchangeRateOnDate(from, to, date);

                FormatDeleteSpecificCurrencyExchangeRateOnDate(ref from, ref to, ref date, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{from}/{to}/{date}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{from}/{to}/{date}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfrom%7D", Uri.EscapeDataString(from.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bto%7D", Uri.EscapeDataString(to.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bdate%7D", Uri.EscapeDataString(date.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteSpecificCurrencyExchangeRateOnDateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteSpecificCurrencyExchangeRateOnDateApiResponse>();
                        DeleteSpecificCurrencyExchangeRateOnDateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{from}/{to}/{date}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteSpecificCurrencyExchangeRateOnDateDefaultImplementation(apiResponseLocalVar, from, to, date, xTraceId);

                        Events.ExecuteOnDeleteSpecificCurrencyExchangeRateOnDate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteSpecificCurrencyExchangeRateOnDateDefaultImplementation(e, "/v1/exchange-rates/{from}/{to}/{date}", uriBuilderLocalVar.Path, from, to, date, xTraceId);
                Events.ExecuteOnErrorDeleteSpecificCurrencyExchangeRateOnDate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>
        /// </summary>
        public partial class DeleteSpecificCurrencyExchangeRateOnDateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IDeleteSpecificCurrencyExchangeRateOnDateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteSpecificCurrencyExchangeRateOnDateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSpecificCurrencyExchangeRateOnDateApiResponse(ILogger<DeleteSpecificCurrencyExchangeRateOnDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteSpecificCurrencyExchangeRateOnDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSpecificCurrencyExchangeRateOnDateApiResponse(ILogger<DeleteSpecificCurrencyExchangeRateOnDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteSpecificCurrencyExchangeRates(ref string from, ref string to, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <returns></returns>
        private void ValidateDeleteSpecificCurrencyExchangeRates(string from, string to)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));

            if (to == null)
                throw new ArgumentNullException(nameof(to));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        private void AfterDeleteSpecificCurrencyExchangeRatesDefaultImplementation(IDeleteSpecificCurrencyExchangeRatesApiResponse apiResponseLocalVar, string from, string to, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteSpecificCurrencyExchangeRates(ref suppressDefaultLog, apiResponseLocalVar, from, to, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        partial void AfterDeleteSpecificCurrencyExchangeRates(ref bool suppressDefaultLog, IDeleteSpecificCurrencyExchangeRatesApiResponse apiResponseLocalVar, string from, string to, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorDeleteSpecificCurrencyExchangeRatesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteSpecificCurrencyExchangeRates(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, from, to, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorDeleteSpecificCurrencyExchangeRates(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, Option<Guid> xTraceId);

        /// <summary>
        /// Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;. Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;. It&#39;s important to know that the reverse exchange rates (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </summary>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        public async Task<IDeleteSpecificCurrencyExchangeRatesApiResponse?> DeleteSpecificCurrencyExchangeRatesOrDefaultAsync(string from, string to, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteSpecificCurrencyExchangeRatesAsync(from, to, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;. Deletes ALL currency exchange rates from &#39;from&#39; to &#39;to&#39;. It&#39;s important to know that the reverse exchange rates (from &#39;to&#39; to &#39;from&#39;) will not be deleted and Firefly III will still be able to infer the correct exchange rate from the reverse one.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteSpecificCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        public async Task<IDeleteSpecificCurrencyExchangeRatesApiResponse> DeleteSpecificCurrencyExchangeRatesAsync(string from, string to, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteSpecificCurrencyExchangeRates(from, to);

                FormatDeleteSpecificCurrencyExchangeRates(ref from, ref to, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{from}/{to}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{from}/{to}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfrom%7D", Uri.EscapeDataString(from.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bto%7D", Uri.EscapeDataString(to.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteSpecificCurrencyExchangeRatesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteSpecificCurrencyExchangeRatesApiResponse>();
                        DeleteSpecificCurrencyExchangeRatesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{from}/{to}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteSpecificCurrencyExchangeRatesDefaultImplementation(apiResponseLocalVar, from, to, xTraceId);

                        Events.ExecuteOnDeleteSpecificCurrencyExchangeRates(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteSpecificCurrencyExchangeRatesDefaultImplementation(e, "/v1/exchange-rates/{from}/{to}", uriBuilderLocalVar.Path, from, to, xTraceId);
                Events.ExecuteOnErrorDeleteSpecificCurrencyExchangeRates(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteSpecificCurrencyExchangeRatesApiResponse"/>
        /// </summary>
        public partial class DeleteSpecificCurrencyExchangeRatesApiResponse : Brotal.FireflyIII.Client.ApiResponse, IDeleteSpecificCurrencyExchangeRatesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteSpecificCurrencyExchangeRatesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteSpecificCurrencyExchangeRatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSpecificCurrencyExchangeRatesApiResponse(ILogger<DeleteSpecificCurrencyExchangeRatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteSpecificCurrencyExchangeRatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteSpecificCurrencyExchangeRatesApiResponse(ILogger<DeleteSpecificCurrencyExchangeRatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListCurrencyExchangeRates(ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterListCurrencyExchangeRatesDefaultImplementation(IListCurrencyExchangeRatesApiResponse apiResponseLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLog = false;
            AfterListCurrencyExchangeRates(ref suppressDefaultLog, apiResponseLocalVar, xTraceId, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterListCurrencyExchangeRates(ref bool suppressDefaultLog, IListCurrencyExchangeRatesApiResponse apiResponseLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorListCurrencyExchangeRatesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListCurrencyExchangeRates(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xTraceId, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorListCurrencyExchangeRates(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// List all exchange rates that Firefly III knows. List exchange rates that Firefly III knows.
        /// </summary>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        public async Task<IListCurrencyExchangeRatesApiResponse?> ListCurrencyExchangeRatesOrDefaultAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListCurrencyExchangeRatesAsync(xTraceId, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all exchange rates that Firefly III knows. List exchange rates that Firefly III knows.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        public async Task<IListCurrencyExchangeRatesApiResponse> ListCurrencyExchangeRatesAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatListCurrencyExchangeRates(ref xTraceId, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListCurrencyExchangeRatesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListCurrencyExchangeRatesApiResponse>();
                        ListCurrencyExchangeRatesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListCurrencyExchangeRatesDefaultImplementation(apiResponseLocalVar, xTraceId, limit, page);

                        Events.ExecuteOnListCurrencyExchangeRates(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListCurrencyExchangeRatesDefaultImplementation(e, "/v1/exchange-rates", uriBuilderLocalVar.Path, xTraceId, limit, page);
                Events.ExecuteOnErrorListCurrencyExchangeRates(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListCurrencyExchangeRatesApiResponse"/>
        /// </summary>
        public partial class ListCurrencyExchangeRatesApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListCurrencyExchangeRatesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListCurrencyExchangeRatesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListCurrencyExchangeRatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListCurrencyExchangeRatesApiResponse(ILogger<ListCurrencyExchangeRatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListCurrencyExchangeRatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListCurrencyExchangeRatesApiResponse(ILogger<ListCurrencyExchangeRatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListSpecificCurrencyExchangeRate(ref string id, ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateListSpecificCurrencyExchangeRate(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterListSpecificCurrencyExchangeRateDefaultImplementation(IListSpecificCurrencyExchangeRateApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLog = false;
            AfterListSpecificCurrencyExchangeRate(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterListSpecificCurrencyExchangeRate(ref bool suppressDefaultLog, IListSpecificCurrencyExchangeRateApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorListSpecificCurrencyExchangeRateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListSpecificCurrencyExchangeRate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorListSpecificCurrencyExchangeRate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// List a single specific exchange rate. List a single specific exchange rate by its ID.
        /// </summary>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IListSpecificCurrencyExchangeRateApiResponse?> ListSpecificCurrencyExchangeRateOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListSpecificCurrencyExchangeRateAsync(id, xTraceId, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List a single specific exchange rate. List a single specific exchange rate by its ID.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested currency exchange rate.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IListSpecificCurrencyExchangeRateApiResponse> ListSpecificCurrencyExchangeRateAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListSpecificCurrencyExchangeRate(id);

                FormatListSpecificCurrencyExchangeRate(ref id, ref xTraceId, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListSpecificCurrencyExchangeRateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListSpecificCurrencyExchangeRateApiResponse>();
                        ListSpecificCurrencyExchangeRateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListSpecificCurrencyExchangeRateDefaultImplementation(apiResponseLocalVar, id, xTraceId, limit, page);

                        Events.ExecuteOnListSpecificCurrencyExchangeRate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListSpecificCurrencyExchangeRateDefaultImplementation(e, "/v1/exchange-rates/{id}", uriBuilderLocalVar.Path, id, xTraceId, limit, page);
                Events.ExecuteOnErrorListSpecificCurrencyExchangeRate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListSpecificCurrencyExchangeRateApiResponse"/>
        /// </summary>
        public partial class ListSpecificCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListSpecificCurrencyExchangeRateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListSpecificCurrencyExchangeRateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListSpecificCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSpecificCurrencyExchangeRateApiResponse(ILogger<ListSpecificCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListSpecificCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSpecificCurrencyExchangeRateApiResponse(ILogger<ListSpecificCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListSpecificCurrencyExchangeRateOnDate(ref string from, ref string to, ref string date, ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <returns></returns>
        private void ValidateListSpecificCurrencyExchangeRateOnDate(string from, string to, string date)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));

            if (to == null)
                throw new ArgumentNullException(nameof(to));

            if (date == null)
                throw new ArgumentNullException(nameof(date));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterListSpecificCurrencyExchangeRateOnDateDefaultImplementation(IListSpecificCurrencyExchangeRateOnDateApiResponse apiResponseLocalVar, string from, string to, string date, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLog = false;
            AfterListSpecificCurrencyExchangeRateOnDate(ref suppressDefaultLog, apiResponseLocalVar, from, to, date, xTraceId, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterListSpecificCurrencyExchangeRateOnDate(ref bool suppressDefaultLog, IListSpecificCurrencyExchangeRateOnDateApiResponse apiResponseLocalVar, string from, string to, string date, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorListSpecificCurrencyExchangeRateOnDateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, string date, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListSpecificCurrencyExchangeRateOnDate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, from, to, date, xTraceId, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorListSpecificCurrencyExchangeRateOnDate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, string date, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// List the exchange rate for the from and to-currency on the requested date. List the exchange rate for the from and to-currency on the requested date.
        /// </summary>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateOnDateApiResponse"/>&gt;</returns>
        public async Task<IListSpecificCurrencyExchangeRateOnDateApiResponse?> ListSpecificCurrencyExchangeRateOnDateOrDefaultAsync(string from, string to, string date, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListSpecificCurrencyExchangeRateOnDateAsync(from, to, date, xTraceId, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List the exchange rate for the from and to-currency on the requested date. List the exchange rate for the from and to-currency on the requested date.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRateOnDateApiResponse"/>&gt;</returns>
        public async Task<IListSpecificCurrencyExchangeRateOnDateApiResponse> ListSpecificCurrencyExchangeRateOnDateAsync(string from, string to, string date, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListSpecificCurrencyExchangeRateOnDate(from, to, date);

                FormatListSpecificCurrencyExchangeRateOnDate(ref from, ref to, ref date, ref xTraceId, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{from}/{to}/{date}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{from}/{to}/{date}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfrom%7D", Uri.EscapeDataString(from.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bto%7D", Uri.EscapeDataString(to.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bdate%7D", Uri.EscapeDataString(date.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListSpecificCurrencyExchangeRateOnDateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListSpecificCurrencyExchangeRateOnDateApiResponse>();
                        ListSpecificCurrencyExchangeRateOnDateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{from}/{to}/{date}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListSpecificCurrencyExchangeRateOnDateDefaultImplementation(apiResponseLocalVar, from, to, date, xTraceId, limit, page);

                        Events.ExecuteOnListSpecificCurrencyExchangeRateOnDate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListSpecificCurrencyExchangeRateOnDateDefaultImplementation(e, "/v1/exchange-rates/{from}/{to}/{date}", uriBuilderLocalVar.Path, from, to, date, xTraceId, limit, page);
                Events.ExecuteOnErrorListSpecificCurrencyExchangeRateOnDate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListSpecificCurrencyExchangeRateOnDateApiResponse"/>
        /// </summary>
        public partial class ListSpecificCurrencyExchangeRateOnDateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListSpecificCurrencyExchangeRateOnDateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListSpecificCurrencyExchangeRateOnDateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListSpecificCurrencyExchangeRateOnDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSpecificCurrencyExchangeRateOnDateApiResponse(ILogger<ListSpecificCurrencyExchangeRateOnDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListSpecificCurrencyExchangeRateOnDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSpecificCurrencyExchangeRateOnDateApiResponse(ILogger<ListSpecificCurrencyExchangeRateOnDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListSpecificCurrencyExchangeRates(ref string from, ref string to, ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <returns></returns>
        private void ValidateListSpecificCurrencyExchangeRates(string from, string to)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));

            if (to == null)
                throw new ArgumentNullException(nameof(to));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterListSpecificCurrencyExchangeRatesDefaultImplementation(IListSpecificCurrencyExchangeRatesApiResponse apiResponseLocalVar, string from, string to, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLog = false;
            AfterListSpecificCurrencyExchangeRates(ref suppressDefaultLog, apiResponseLocalVar, from, to, xTraceId, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterListSpecificCurrencyExchangeRates(ref bool suppressDefaultLog, IListSpecificCurrencyExchangeRatesApiResponse apiResponseLocalVar, string from, string to, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorListSpecificCurrencyExchangeRatesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListSpecificCurrencyExchangeRates(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, from, to, xTraceId, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorListSpecificCurrencyExchangeRates(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// List all exchange rates from/to the mentioned currencies. List all exchange rates from/to the mentioned currencies.
        /// </summary>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        public async Task<IListSpecificCurrencyExchangeRatesApiResponse?> ListSpecificCurrencyExchangeRatesOrDefaultAsync(string from, string to, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListSpecificCurrencyExchangeRatesAsync(from, to, xTraceId, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all exchange rates from/to the mentioned currencies. List all exchange rates from/to the mentioned currencies.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSpecificCurrencyExchangeRatesApiResponse"/>&gt;</returns>
        public async Task<IListSpecificCurrencyExchangeRatesApiResponse> ListSpecificCurrencyExchangeRatesAsync(string from, string to, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListSpecificCurrencyExchangeRates(from, to);

                FormatListSpecificCurrencyExchangeRates(ref from, ref to, ref xTraceId, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{from}/{to}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{from}/{to}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfrom%7D", Uri.EscapeDataString(from.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bto%7D", Uri.EscapeDataString(to.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListSpecificCurrencyExchangeRatesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListSpecificCurrencyExchangeRatesApiResponse>();
                        ListSpecificCurrencyExchangeRatesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{from}/{to}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListSpecificCurrencyExchangeRatesDefaultImplementation(apiResponseLocalVar, from, to, xTraceId, limit, page);

                        Events.ExecuteOnListSpecificCurrencyExchangeRates(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListSpecificCurrencyExchangeRatesDefaultImplementation(e, "/v1/exchange-rates/{from}/{to}", uriBuilderLocalVar.Path, from, to, xTraceId, limit, page);
                Events.ExecuteOnErrorListSpecificCurrencyExchangeRates(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListSpecificCurrencyExchangeRatesApiResponse"/>
        /// </summary>
        public partial class ListSpecificCurrencyExchangeRatesApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListSpecificCurrencyExchangeRatesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListSpecificCurrencyExchangeRatesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListSpecificCurrencyExchangeRatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSpecificCurrencyExchangeRatesApiResponse(ILogger<ListSpecificCurrencyExchangeRatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListSpecificCurrencyExchangeRatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSpecificCurrencyExchangeRatesApiResponse(ILogger<ListSpecificCurrencyExchangeRatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStoreCurrencyExchangeRate(CurrencyExchangeRateStore currencyExchangeRateStore, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="currencyExchangeRateStore"></param>
        /// <returns></returns>
        private void ValidateStoreCurrencyExchangeRate(CurrencyExchangeRateStore currencyExchangeRateStore)
        {
            if (currencyExchangeRateStore == null)
                throw new ArgumentNullException(nameof(currencyExchangeRateStore));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="currencyExchangeRateStore"></param>
        /// <param name="xTraceId"></param>
        private void AfterStoreCurrencyExchangeRateDefaultImplementation(IStoreCurrencyExchangeRateApiResponse apiResponseLocalVar, CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterStoreCurrencyExchangeRate(ref suppressDefaultLog, apiResponseLocalVar, currencyExchangeRateStore, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="currencyExchangeRateStore"></param>
        /// <param name="xTraceId"></param>
        partial void AfterStoreCurrencyExchangeRate(ref bool suppressDefaultLog, IStoreCurrencyExchangeRateApiResponse apiResponseLocalVar, CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="currencyExchangeRateStore"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorStoreCurrencyExchangeRateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStoreCurrencyExchangeRate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, currencyExchangeRateStore, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="currencyExchangeRateStore"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorStoreCurrencyExchangeRate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId);

        /// <summary>
        /// Store a new currency exchange rate. Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
        /// </summary>
        /// <param name="currencyExchangeRateStore">JSON array or key&#x3D;value pairs with the necessary exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IStoreCurrencyExchangeRateApiResponse?> StoreCurrencyExchangeRateOrDefaultAsync(CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await StoreCurrencyExchangeRateAsync(currencyExchangeRateStore, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Store a new currency exchange rate. Stores a new exchange rate. The data required can be submitted as a JSON body or as a list of parameters.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="currencyExchangeRateStore">JSON array or key&#x3D;value pairs with the necessary exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IStoreCurrencyExchangeRateApiResponse> StoreCurrencyExchangeRateAsync(CurrencyExchangeRateStore currencyExchangeRateStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStoreCurrencyExchangeRate(currencyExchangeRateStore);

                FormatStoreCurrencyExchangeRate(currencyExchangeRateStore, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates");

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (currencyExchangeRateStore as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(currencyExchangeRateStore, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<StoreCurrencyExchangeRateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<StoreCurrencyExchangeRateApiResponse>();
                        StoreCurrencyExchangeRateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterStoreCurrencyExchangeRateDefaultImplementation(apiResponseLocalVar, currencyExchangeRateStore, xTraceId);

                        Events.ExecuteOnStoreCurrencyExchangeRate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorStoreCurrencyExchangeRateDefaultImplementation(e, "/v1/exchange-rates", uriBuilderLocalVar.Path, currencyExchangeRateStore, xTraceId);
                Events.ExecuteOnErrorStoreCurrencyExchangeRate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="StoreCurrencyExchangeRateApiResponse"/>
        /// </summary>
        public partial class StoreCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IStoreCurrencyExchangeRateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<StoreCurrencyExchangeRateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="StoreCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreCurrencyExchangeRateApiResponse(ILogger<StoreCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="StoreCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreCurrencyExchangeRateApiResponse(ILogger<StoreCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStoreCurrencyExchangeRatesByDate(ref string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate"></param>
        /// <returns></returns>
        private void ValidateStoreCurrencyExchangeRatesByDate(string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate)
        {
            if (date == null)
                throw new ArgumentNullException(nameof(date));

            if (currencyExchangeRateStoreByDate == null)
                throw new ArgumentNullException(nameof(currencyExchangeRateStoreByDate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate"></param>
        /// <param name="xTraceId"></param>
        private void AfterStoreCurrencyExchangeRatesByDateDefaultImplementation(IStoreCurrencyExchangeRatesByDateApiResponse apiResponseLocalVar, string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterStoreCurrencyExchangeRatesByDate(ref suppressDefaultLog, apiResponseLocalVar, date, currencyExchangeRateStoreByDate, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate"></param>
        /// <param name="xTraceId"></param>
        partial void AfterStoreCurrencyExchangeRatesByDate(ref bool suppressDefaultLog, IStoreCurrencyExchangeRatesByDateApiResponse apiResponseLocalVar, string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorStoreCurrencyExchangeRatesByDateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStoreCurrencyExchangeRatesByDate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, date, currencyExchangeRateStoreByDate, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorStoreCurrencyExchangeRatesByDate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId);

        /// <summary>
        /// Store new currency exchange rates under this date Stores a new set of exchange rates. The date is fixed (in the URL parameter) and the data required can be submitted as a JSON body.
        /// </summary>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByDateApiResponse"/>&gt;</returns>
        public async Task<IStoreCurrencyExchangeRatesByDateApiResponse?> StoreCurrencyExchangeRatesByDateOrDefaultAsync(string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await StoreCurrencyExchangeRatesByDateAsync(date, currencyExchangeRateStoreByDate, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Store new currency exchange rates under this date Stores a new set of exchange rates. The date is fixed (in the URL parameter) and the data required can be submitted as a JSON body.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateStoreByDate">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByDateApiResponse"/>&gt;</returns>
        public async Task<IStoreCurrencyExchangeRatesByDateApiResponse> StoreCurrencyExchangeRatesByDateAsync(string date, CurrencyExchangeRateStoreByDate currencyExchangeRateStoreByDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStoreCurrencyExchangeRatesByDate(date, currencyExchangeRateStoreByDate);

                FormatStoreCurrencyExchangeRatesByDate(ref date, currencyExchangeRateStoreByDate, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/by-date/{date}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/by-date/{date}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bdate%7D", Uri.EscapeDataString(date.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (currencyExchangeRateStoreByDate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(currencyExchangeRateStoreByDate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<StoreCurrencyExchangeRatesByDateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<StoreCurrencyExchangeRatesByDateApiResponse>();
                        StoreCurrencyExchangeRatesByDateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/by-date/{date}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterStoreCurrencyExchangeRatesByDateDefaultImplementation(apiResponseLocalVar, date, currencyExchangeRateStoreByDate, xTraceId);

                        Events.ExecuteOnStoreCurrencyExchangeRatesByDate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorStoreCurrencyExchangeRatesByDateDefaultImplementation(e, "/v1/exchange-rates/by-date/{date}", uriBuilderLocalVar.Path, date, currencyExchangeRateStoreByDate, xTraceId);
                Events.ExecuteOnErrorStoreCurrencyExchangeRatesByDate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="StoreCurrencyExchangeRatesByDateApiResponse"/>
        /// </summary>
        public partial class StoreCurrencyExchangeRatesByDateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IStoreCurrencyExchangeRatesByDateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<StoreCurrencyExchangeRatesByDateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="StoreCurrencyExchangeRatesByDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreCurrencyExchangeRatesByDateApiResponse(ILogger<StoreCurrencyExchangeRatesByDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="StoreCurrencyExchangeRatesByDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreCurrencyExchangeRatesByDateApiResponse(ILogger<StoreCurrencyExchangeRatesByDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStoreCurrencyExchangeRatesByPair(ref string from, ref string to, Dictionary<string, string> requestBody, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="requestBody"></param>
        /// <returns></returns>
        private void ValidateStoreCurrencyExchangeRatesByPair(string from, string to, Dictionary<string, string> requestBody)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));

            if (to == null)
                throw new ArgumentNullException(nameof(to));

            if (requestBody == null)
                throw new ArgumentNullException(nameof(requestBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="requestBody"></param>
        /// <param name="xTraceId"></param>
        private void AfterStoreCurrencyExchangeRatesByPairDefaultImplementation(IStoreCurrencyExchangeRatesByPairApiResponse apiResponseLocalVar, string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterStoreCurrencyExchangeRatesByPair(ref suppressDefaultLog, apiResponseLocalVar, from, to, requestBody, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="requestBody"></param>
        /// <param name="xTraceId"></param>
        partial void AfterStoreCurrencyExchangeRatesByPair(ref bool suppressDefaultLog, IStoreCurrencyExchangeRatesByPairApiResponse apiResponseLocalVar, string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="requestBody"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorStoreCurrencyExchangeRatesByPairDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStoreCurrencyExchangeRatesByPair(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, from, to, requestBody, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="requestBody"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorStoreCurrencyExchangeRatesByPair(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId);

        /// <summary>
        /// Store new currency exchange rates under this from/to pair. Stores a new set of exchange rates for this pair. The date is variable, and the data required can be submitted as a JSON body.
        /// </summary>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="requestBody">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByPairApiResponse"/>&gt;</returns>
        public async Task<IStoreCurrencyExchangeRatesByPairApiResponse?> StoreCurrencyExchangeRatesByPairOrDefaultAsync(string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await StoreCurrencyExchangeRatesByPairAsync(from, to, requestBody, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Store new currency exchange rates under this from/to pair. Stores a new set of exchange rates for this pair. The date is variable, and the data required can be submitted as a JSON body.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="requestBody">JSON array with the necessary currency exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreCurrencyExchangeRatesByPairApiResponse"/>&gt;</returns>
        public async Task<IStoreCurrencyExchangeRatesByPairApiResponse> StoreCurrencyExchangeRatesByPairAsync(string from, string to, Dictionary<string, string> requestBody, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStoreCurrencyExchangeRatesByPair(from, to, requestBody);

                FormatStoreCurrencyExchangeRatesByPair(ref from, ref to, requestBody, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/by-currencies/{from}/{to}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/by-currencies/{from}/{to}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfrom%7D", Uri.EscapeDataString(from.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bto%7D", Uri.EscapeDataString(to.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (requestBody as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(requestBody, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<StoreCurrencyExchangeRatesByPairApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<StoreCurrencyExchangeRatesByPairApiResponse>();
                        StoreCurrencyExchangeRatesByPairApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/by-currencies/{from}/{to}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterStoreCurrencyExchangeRatesByPairDefaultImplementation(apiResponseLocalVar, from, to, requestBody, xTraceId);

                        Events.ExecuteOnStoreCurrencyExchangeRatesByPair(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorStoreCurrencyExchangeRatesByPairDefaultImplementation(e, "/v1/exchange-rates/by-currencies/{from}/{to}", uriBuilderLocalVar.Path, from, to, requestBody, xTraceId);
                Events.ExecuteOnErrorStoreCurrencyExchangeRatesByPair(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="StoreCurrencyExchangeRatesByPairApiResponse"/>
        /// </summary>
        public partial class StoreCurrencyExchangeRatesByPairApiResponse : Brotal.FireflyIII.Client.ApiResponse, IStoreCurrencyExchangeRatesByPairApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<StoreCurrencyExchangeRatesByPairApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="StoreCurrencyExchangeRatesByPairApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreCurrencyExchangeRatesByPairApiResponse(ILogger<StoreCurrencyExchangeRatesByPairApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="StoreCurrencyExchangeRatesByPairApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreCurrencyExchangeRatesByPairApiResponse(ILogger<StoreCurrencyExchangeRatesByPairApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateCurrencyExchangeRate(ref string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="currencyExchangeRateUpdate"></param>
        /// <returns></returns>
        private void ValidateUpdateCurrencyExchangeRate(string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (currencyExchangeRateUpdate == null)
                throw new ArgumentNullException(nameof(currencyExchangeRateUpdate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="currencyExchangeRateUpdate"></param>
        /// <param name="xTraceId"></param>
        private void AfterUpdateCurrencyExchangeRateDefaultImplementation(IUpdateCurrencyExchangeRateApiResponse apiResponseLocalVar, string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterUpdateCurrencyExchangeRate(ref suppressDefaultLog, apiResponseLocalVar, id, currencyExchangeRateUpdate, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="currencyExchangeRateUpdate"></param>
        /// <param name="xTraceId"></param>
        partial void AfterUpdateCurrencyExchangeRate(ref bool suppressDefaultLog, IUpdateCurrencyExchangeRateApiResponse apiResponseLocalVar, string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="currencyExchangeRateUpdate"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorUpdateCurrencyExchangeRateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateCurrencyExchangeRate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, currencyExchangeRateUpdate, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="currencyExchangeRateUpdate"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorUpdateCurrencyExchangeRate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId);

        /// <summary>
        /// Update existing currency exchange rate. Used to update a single currency exchange rate by its ID. Including the from/to currency is optional. 
        /// </summary>
        /// <param name="id">The ID of the currency exchange rate.</param>
        /// <param name="currencyExchangeRateUpdate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IUpdateCurrencyExchangeRateApiResponse?> UpdateCurrencyExchangeRateOrDefaultAsync(string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateCurrencyExchangeRateAsync(id, currencyExchangeRateUpdate, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update existing currency exchange rate. Used to update a single currency exchange rate by its ID. Including the from/to currency is optional. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the currency exchange rate.</param>
        /// <param name="currencyExchangeRateUpdate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateApiResponse"/>&gt;</returns>
        public async Task<IUpdateCurrencyExchangeRateApiResponse> UpdateCurrencyExchangeRateAsync(string id, CurrencyExchangeRateUpdate currencyExchangeRateUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateCurrencyExchangeRate(id, currencyExchangeRateUpdate);

                FormatUpdateCurrencyExchangeRate(ref id, currencyExchangeRateUpdate, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (currencyExchangeRateUpdate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(currencyExchangeRateUpdate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateCurrencyExchangeRateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateCurrencyExchangeRateApiResponse>();
                        UpdateCurrencyExchangeRateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateCurrencyExchangeRateDefaultImplementation(apiResponseLocalVar, id, currencyExchangeRateUpdate, xTraceId);

                        Events.ExecuteOnUpdateCurrencyExchangeRate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateCurrencyExchangeRateDefaultImplementation(e, "/v1/exchange-rates/{id}", uriBuilderLocalVar.Path, id, currencyExchangeRateUpdate, xTraceId);
                Events.ExecuteOnErrorUpdateCurrencyExchangeRate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateCurrencyExchangeRateApiResponse"/>
        /// </summary>
        public partial class UpdateCurrencyExchangeRateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IUpdateCurrencyExchangeRateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateCurrencyExchangeRateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateCurrencyExchangeRateApiResponse(ILogger<UpdateCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateCurrencyExchangeRateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateCurrencyExchangeRateApiResponse(ILogger<UpdateCurrencyExchangeRateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateCurrencyExchangeRateByDate(ref string from, ref string to, ref string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate"></param>
        /// <returns></returns>
        private void ValidateUpdateCurrencyExchangeRateByDate(string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate)
        {
            if (from == null)
                throw new ArgumentNullException(nameof(from));

            if (to == null)
                throw new ArgumentNullException(nameof(to));

            if (date == null)
                throw new ArgumentNullException(nameof(date));

            if (currencyExchangeRateUpdateNoDate == null)
                throw new ArgumentNullException(nameof(currencyExchangeRateUpdateNoDate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate"></param>
        /// <param name="xTraceId"></param>
        private void AfterUpdateCurrencyExchangeRateByDateDefaultImplementation(IUpdateCurrencyExchangeRateByDateApiResponse apiResponseLocalVar, string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterUpdateCurrencyExchangeRateByDate(ref suppressDefaultLog, apiResponseLocalVar, from, to, date, currencyExchangeRateUpdateNoDate, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate"></param>
        /// <param name="xTraceId"></param>
        partial void AfterUpdateCurrencyExchangeRateByDate(ref bool suppressDefaultLog, IUpdateCurrencyExchangeRateByDateApiResponse apiResponseLocalVar, string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorUpdateCurrencyExchangeRateByDateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateCurrencyExchangeRateByDate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, from, to, date, currencyExchangeRateUpdateNoDate, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorUpdateCurrencyExchangeRateByDate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId);

        /// <summary>
        /// Update existing currency exchange rate. Used to update a single currency exchange rate by its currency codes and date 
        /// </summary>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateByDateApiResponse"/>&gt;</returns>
        public async Task<IUpdateCurrencyExchangeRateByDateApiResponse?> UpdateCurrencyExchangeRateByDateOrDefaultAsync(string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateCurrencyExchangeRateByDateAsync(from, to, date, currencyExchangeRateUpdateNoDate, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update existing currency exchange rate. Used to update a single currency exchange rate by its currency codes and date 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="from">The currency code of the &#39;from&#39; currency.</param>
        /// <param name="to">The currency code of the &#39;to&#39; currency.</param>
        /// <param name="date"></param>
        /// <param name="currencyExchangeRateUpdateNoDate">JSON array or form-data with updated exchange rate information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateCurrencyExchangeRateByDateApiResponse"/>&gt;</returns>
        public async Task<IUpdateCurrencyExchangeRateByDateApiResponse> UpdateCurrencyExchangeRateByDateAsync(string from, string to, string date, CurrencyExchangeRateUpdateNoDate currencyExchangeRateUpdateNoDate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateCurrencyExchangeRateByDate(from, to, date, currencyExchangeRateUpdateNoDate);

                FormatUpdateCurrencyExchangeRateByDate(ref from, ref to, ref date, currencyExchangeRateUpdateNoDate, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/exchange-rates/{from}/{to}/{date}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/exchange-rates/{from}/{to}/{date}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfrom%7D", Uri.EscapeDataString(from.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bto%7D", Uri.EscapeDataString(to.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bdate%7D", Uri.EscapeDataString(date.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (currencyExchangeRateUpdateNoDate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(currencyExchangeRateUpdateNoDate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateCurrencyExchangeRateByDateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateCurrencyExchangeRateByDateApiResponse>();
                        UpdateCurrencyExchangeRateByDateApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/exchange-rates/{from}/{to}/{date}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateCurrencyExchangeRateByDateDefaultImplementation(apiResponseLocalVar, from, to, date, currencyExchangeRateUpdateNoDate, xTraceId);

                        Events.ExecuteOnUpdateCurrencyExchangeRateByDate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateCurrencyExchangeRateByDateDefaultImplementation(e, "/v1/exchange-rates/{from}/{to}/{date}", uriBuilderLocalVar.Path, from, to, date, currencyExchangeRateUpdateNoDate, xTraceId);
                Events.ExecuteOnErrorUpdateCurrencyExchangeRateByDate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateCurrencyExchangeRateByDateApiResponse"/>
        /// </summary>
        public partial class UpdateCurrencyExchangeRateByDateApiResponse : Brotal.FireflyIII.Client.ApiResponse, IUpdateCurrencyExchangeRateByDateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateCurrencyExchangeRateByDateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateCurrencyExchangeRateByDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateCurrencyExchangeRateByDateApiResponse(ILogger<UpdateCurrencyExchangeRateByDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateCurrencyExchangeRateByDateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateCurrencyExchangeRateByDateApiResponse(ILogger<UpdateCurrencyExchangeRateByDateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.CurrencyExchangeRateSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.CurrencyExchangeRateSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
