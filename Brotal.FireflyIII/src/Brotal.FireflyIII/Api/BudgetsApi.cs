// <auto-generated>
/*
 * Firefly III API v6.3.0
 *
 * This is the documentation of the Firefly III API. Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. <br><br> Please keep in mind that the demo site does **not** accept requests from `curl`, `colly`, `wget`, etc. You must use a browser or a tool like Insomnia to make your test requests. <br><br> To learn more about the idiosyncrasies of this API, please read about the API in the [Firefly III API documentation](https://docs.firefly-iii.org/references/firefly-iii/api/). <br><br> <small>This file was last generated on 2025-08-16 @ 20:21:49 (Europe/Amsterdam)</small> 
 *
 * The version of the OpenAPI document: v6.3.0
 * Contact: james@firefly-iii.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Brotal.FireflyIII.Client;
using Brotal.FireflyIII.Model;
using System.Diagnostics.CodeAnalysis;

namespace Brotal.FireflyIII.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IBudgetsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        BudgetsApiEvents Events { get; }

        /// <summary>
        /// Delete a budget.
        /// </summary>
        /// <remarks>
        /// Delete a budget. Transactions will not be deleted.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetApiResponse"/>&gt;</returns>
        Task<IDeleteBudgetApiResponse> DeleteBudgetAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a budget.
        /// </summary>
        /// <remarks>
        /// Delete a budget. Transactions will not be deleted.
        /// </remarks>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetApiResponse"/>?&gt;</returns>
        Task<IDeleteBudgetApiResponse?> DeleteBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a budget limit.
        /// </summary>
        /// <remarks>
        /// Delete a budget limit.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetLimitApiResponse"/>&gt;</returns>
        Task<IDeleteBudgetLimitApiResponse> DeleteBudgetLimitAsync(string id, string limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a budget limit.
        /// </summary>
        /// <remarks>
        /// Delete a budget limit.
        /// </remarks>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetLimitApiResponse"/>?&gt;</returns>
        Task<IDeleteBudgetLimitApiResponse?> DeleteBudgetLimitOrDefaultAsync(string id, string limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a single budget.
        /// </summary>
        /// <remarks>
        /// Get a single budget. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetApiResponse"/>&gt;</returns>
        Task<IGetBudgetApiResponse> GetBudgetAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a single budget.
        /// </summary>
        /// <remarks>
        /// Get a single budget. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </remarks>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetApiResponse"/>?&gt;</returns>
        Task<IGetBudgetApiResponse?> GetBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get single budget limit.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetLimitApiResponse"/>&gt;</returns>
        Task<IGetBudgetLimitApiResponse> GetBudgetLimitAsync(string id, int limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get single budget limit.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetLimitApiResponse"/>?&gt;</returns>
        Task<IGetBudgetLimitApiResponse?> GetBudgetLimitOrDefaultAsync(string id, int limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Lists all attachments of a budget.
        /// </summary>
        /// <remarks>
        /// Lists all attachments.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAttachmentByBudgetApiResponse"/>&gt;</returns>
        Task<IListAttachmentByBudgetApiResponse> ListAttachmentByBudgetAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Lists all attachments of a budget.
        /// </summary>
        /// <remarks>
        /// Lists all attachments.
        /// </remarks>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAttachmentByBudgetApiResponse"/>?&gt;</returns>
        Task<IListAttachmentByBudgetApiResponse?> ListAttachmentByBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all budgets.
        /// </summary>
        /// <remarks>
        /// List all the budgets the user has made. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetApiResponse"/>&gt;</returns>
        Task<IListBudgetApiResponse> ListBudgetAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all budgets.
        /// </summary>
        /// <remarks>
        /// List all the budgets the user has made. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </remarks>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetApiResponse"/>?&gt;</returns>
        Task<IListBudgetApiResponse?> ListBudgetOrDefaultAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get list of budget limits by date
        /// </summary>
        /// <remarks>
        /// Get all budget limits for for this date range. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitApiResponse"/>&gt;</returns>
        Task<IListBudgetLimitApiResponse> ListBudgetLimitAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get list of budget limits by date
        /// </summary>
        /// <remarks>
        /// Get all budget limits for for this date range. 
        /// </remarks>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitApiResponse"/>?&gt;</returns>
        Task<IListBudgetLimitApiResponse?> ListBudgetLimitOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all limits for a budget.
        /// </summary>
        /// <remarks>
        /// Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \&quot;spent\&quot; array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitByBudgetApiResponse"/>&gt;</returns>
        Task<IListBudgetLimitByBudgetApiResponse> ListBudgetLimitByBudgetAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all limits for a budget.
        /// </summary>
        /// <remarks>
        /// Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \&quot;spent\&quot; array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
        /// </remarks>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitByBudgetApiResponse"/>?&gt;</returns>
        Task<IListBudgetLimitByBudgetApiResponse?> ListBudgetLimitByBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// All transactions to a budget.
        /// </summary>
        /// <remarks>
        /// Get all transactions linked to a budget, possibly limited by start and end
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetApiResponse"/>&gt;</returns>
        Task<IListTransactionByBudgetApiResponse> ListTransactionByBudgetAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// All transactions to a budget.
        /// </summary>
        /// <remarks>
        /// Get all transactions linked to a budget, possibly limited by start and end
        /// </remarks>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetApiResponse"/>?&gt;</returns>
        Task<IListTransactionByBudgetApiResponse?> ListTransactionByBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all transactions by a budget limit ID.
        /// </summary>
        /// <remarks>
        /// List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetLimitApiResponse"/>&gt;</returns>
        Task<IListTransactionByBudgetLimitApiResponse> ListTransactionByBudgetLimitAsync(string id, string limitId, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List all transactions by a budget limit ID.
        /// </summary>
        /// <remarks>
        /// List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
        /// </remarks>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetLimitApiResponse"/>?&gt;</returns>
        Task<IListTransactionByBudgetLimitApiResponse?> ListTransactionByBudgetLimitOrDefaultAsync(string id, string limitId, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// All transactions without a budget.
        /// </summary>
        /// <remarks>
        /// Get all transactions NOT linked to a budget, possibly limited by start and end
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionWithoutBudgetApiResponse"/>&gt;</returns>
        Task<IListTransactionWithoutBudgetApiResponse> ListTransactionWithoutBudgetAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// All transactions without a budget.
        /// </summary>
        /// <remarks>
        /// Get all transactions NOT linked to a budget, possibly limited by start and end
        /// </remarks>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionWithoutBudgetApiResponse"/>?&gt;</returns>
        Task<IListTransactionWithoutBudgetApiResponse?> ListTransactionWithoutBudgetOrDefaultAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store a new budget
        /// </summary>
        /// <remarks>
        /// Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="budgetStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetApiResponse"/>&gt;</returns>
        Task<IStoreBudgetApiResponse> StoreBudgetAsync(BudgetStore budgetStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store a new budget
        /// </summary>
        /// <remarks>
        /// Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
        /// </remarks>
        /// <param name="budgetStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetApiResponse"/>?&gt;</returns>
        Task<IStoreBudgetApiResponse?> StoreBudgetOrDefaultAsync(BudgetStore budgetStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store new budget limit.
        /// </summary>
        /// <remarks>
        /// Store a new budget limit under this budget.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetLimitStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetLimitApiResponse"/>&gt;</returns>
        Task<IStoreBudgetLimitApiResponse> StoreBudgetLimitAsync(string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Store new budget limit.
        /// </summary>
        /// <remarks>
        /// Store a new budget limit under this budget.
        /// </remarks>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetLimitStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetLimitApiResponse"/>?&gt;</returns>
        Task<IStoreBudgetLimitApiResponse?> StoreBudgetLimitOrDefaultAsync(string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing budget.
        /// </summary>
        /// <remarks>
        /// Update existing budget. This endpoint cannot be used to set budget amount limits.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetUpdate">JSON array with updated budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetApiResponse"/>&gt;</returns>
        Task<IUpdateBudgetApiResponse> UpdateBudgetAsync(string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing budget.
        /// </summary>
        /// <remarks>
        /// Update existing budget. This endpoint cannot be used to set budget amount limits.
        /// </remarks>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetUpdate">JSON array with updated budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetApiResponse"/>?&gt;</returns>
        Task<IUpdateBudgetApiResponse?> UpdateBudgetOrDefaultAsync(string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing budget limit.
        /// </summary>
        /// <remarks>
        /// Update existing budget limit.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="budgetLimitUpdate">JSON array with updated budget limit information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetLimitApiResponse"/>&gt;</returns>
        Task<IUpdateBudgetLimitApiResponse> UpdateBudgetLimitAsync(string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update existing budget limit.
        /// </summary>
        /// <remarks>
        /// Update existing budget limit.
        /// </remarks>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="budgetLimitUpdate">JSON array with updated budget limit information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetLimitApiResponse"/>?&gt;</returns>
        Task<IUpdateBudgetLimitApiResponse?> UpdateBudgetLimitOrDefaultAsync(string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IDeleteBudgetApiResponse"/>
    /// </summary>
    public interface IDeleteBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteBudgetLimitApiResponse"/>
    /// </summary>
    public interface IDeleteBudgetLimitApiResponse : Brotal.FireflyIII.Client.IApiResponse, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetBudgetApiResponse"/>
    /// </summary>
    public interface IGetBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetSingle?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetBudgetLimitApiResponse"/>
    /// </summary>
    public interface IGetBudgetLimitApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetLimitSingle?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListAttachmentByBudgetApiResponse"/>
    /// </summary>
    public interface IListAttachmentByBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.AttachmentArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListBudgetApiResponse"/>
    /// </summary>
    public interface IListBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListBudgetLimitApiResponse"/>
    /// </summary>
    public interface IListBudgetLimitApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetLimitArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListBudgetLimitByBudgetApiResponse"/>
    /// </summary>
    public interface IListBudgetLimitByBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetLimitArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListTransactionByBudgetApiResponse"/>
    /// </summary>
    public interface IListTransactionByBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.TransactionArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListTransactionByBudgetLimitApiResponse"/>
    /// </summary>
    public interface IListTransactionByBudgetLimitApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.TransactionArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IListTransactionWithoutBudgetApiResponse"/>
    /// </summary>
    public interface IListTransactionWithoutBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.TransactionArray?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IStoreBudgetApiResponse"/>
    /// </summary>
    public interface IStoreBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IStoreBudgetLimitApiResponse"/>
    /// </summary>
    public interface IStoreBudgetLimitApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetLimitSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateBudgetApiResponse"/>
    /// </summary>
    public interface IUpdateBudgetApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateBudgetLimitApiResponse"/>
    /// </summary>
    public interface IUpdateBudgetLimitApiResponse : Brotal.FireflyIII.Client.IApiResponse, IOk<Brotal.FireflyIII.Model.BudgetLimitSingle?>, IUnprocessableContent<Brotal.FireflyIII.Model.ValidationErrorResponse?>, IUnauthorized<Brotal.FireflyIII.Model.UnauthenticatedResponse?>, INotFound<Brotal.FireflyIII.Model.NotFoundResponse?>, IBadRequest<Brotal.FireflyIII.Model.BadRequestResponse?>, IInternalServerError<Brotal.FireflyIII.Model.InternalExceptionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 422 UnprocessableContent
        /// </summary>
        /// <returns></returns>
        bool IsUnprocessableContent { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class BudgetsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteBudget;

        internal void ExecuteOnDeleteBudget(BudgetsApi.DeleteBudgetApiResponse apiResponse)
        {
            OnDeleteBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteBudget(Exception exception)
        {
            OnErrorDeleteBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteBudgetLimit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteBudgetLimit;

        internal void ExecuteOnDeleteBudgetLimit(BudgetsApi.DeleteBudgetLimitApiResponse apiResponse)
        {
            OnDeleteBudgetLimit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteBudgetLimit(Exception exception)
        {
            OnErrorDeleteBudgetLimit?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBudget;

        internal void ExecuteOnGetBudget(BudgetsApi.GetBudgetApiResponse apiResponse)
        {
            OnGetBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBudget(Exception exception)
        {
            OnErrorGetBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetBudgetLimit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetBudgetLimit;

        internal void ExecuteOnGetBudgetLimit(BudgetsApi.GetBudgetLimitApiResponse apiResponse)
        {
            OnGetBudgetLimit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetBudgetLimit(Exception exception)
        {
            OnErrorGetBudgetLimit?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListAttachmentByBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListAttachmentByBudget;

        internal void ExecuteOnListAttachmentByBudget(BudgetsApi.ListAttachmentByBudgetApiResponse apiResponse)
        {
            OnListAttachmentByBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListAttachmentByBudget(Exception exception)
        {
            OnErrorListAttachmentByBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListBudget;

        internal void ExecuteOnListBudget(BudgetsApi.ListBudgetApiResponse apiResponse)
        {
            OnListBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListBudget(Exception exception)
        {
            OnErrorListBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListBudgetLimit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListBudgetLimit;

        internal void ExecuteOnListBudgetLimit(BudgetsApi.ListBudgetLimitApiResponse apiResponse)
        {
            OnListBudgetLimit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListBudgetLimit(Exception exception)
        {
            OnErrorListBudgetLimit?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListBudgetLimitByBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListBudgetLimitByBudget;

        internal void ExecuteOnListBudgetLimitByBudget(BudgetsApi.ListBudgetLimitByBudgetApiResponse apiResponse)
        {
            OnListBudgetLimitByBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListBudgetLimitByBudget(Exception exception)
        {
            OnErrorListBudgetLimitByBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListTransactionByBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListTransactionByBudget;

        internal void ExecuteOnListTransactionByBudget(BudgetsApi.ListTransactionByBudgetApiResponse apiResponse)
        {
            OnListTransactionByBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListTransactionByBudget(Exception exception)
        {
            OnErrorListTransactionByBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListTransactionByBudgetLimit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListTransactionByBudgetLimit;

        internal void ExecuteOnListTransactionByBudgetLimit(BudgetsApi.ListTransactionByBudgetLimitApiResponse apiResponse)
        {
            OnListTransactionByBudgetLimit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListTransactionByBudgetLimit(Exception exception)
        {
            OnErrorListTransactionByBudgetLimit?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListTransactionWithoutBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListTransactionWithoutBudget;

        internal void ExecuteOnListTransactionWithoutBudget(BudgetsApi.ListTransactionWithoutBudgetApiResponse apiResponse)
        {
            OnListTransactionWithoutBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListTransactionWithoutBudget(Exception exception)
        {
            OnErrorListTransactionWithoutBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStoreBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStoreBudget;

        internal void ExecuteOnStoreBudget(BudgetsApi.StoreBudgetApiResponse apiResponse)
        {
            OnStoreBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStoreBudget(Exception exception)
        {
            OnErrorStoreBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnStoreBudgetLimit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorStoreBudgetLimit;

        internal void ExecuteOnStoreBudgetLimit(BudgetsApi.StoreBudgetLimitApiResponse apiResponse)
        {
            OnStoreBudgetLimit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorStoreBudgetLimit(Exception exception)
        {
            OnErrorStoreBudgetLimit?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateBudget;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateBudget;

        internal void ExecuteOnUpdateBudget(BudgetsApi.UpdateBudgetApiResponse apiResponse)
        {
            OnUpdateBudget?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateBudget(Exception exception)
        {
            OnErrorUpdateBudget?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateBudgetLimit;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateBudgetLimit;

        internal void ExecuteOnUpdateBudgetLimit(BudgetsApi.UpdateBudgetLimitApiResponse apiResponse)
        {
            OnUpdateBudgetLimit?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateBudgetLimit(Exception exception)
        {
            OnErrorUpdateBudgetLimit?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class BudgetsApi : IBudgetsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<BudgetsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public BudgetsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// A token provider of type <see cref="OauthTokenProvider"/>
        /// </summary>
        public TokenProvider<OAuthToken> OauthTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="BudgetsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BudgetsApi(ILogger<BudgetsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, BudgetsApiEvents budgetsApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider,
            TokenProvider<OAuthToken> oauthTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<BudgetsApi>();
            HttpClient = httpClient;
            Events = budgetsApiEvents;
            BearerTokenProvider = bearerTokenProvider;
            OauthTokenProvider = oauthTokenProvider;
        }

        partial void FormatDeleteBudget(ref string id, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteBudget(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        private void AfterDeleteBudgetDefaultImplementation(IDeleteBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteBudget(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        partial void AfterDeleteBudget(ref bool suppressDefaultLog, IDeleteBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorDeleteBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorDeleteBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId);

        /// <summary>
        /// Delete a budget. Delete a budget. Transactions will not be deleted.
        /// </summary>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetApiResponse"/>&gt;</returns>
        public async Task<IDeleteBudgetApiResponse?> DeleteBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteBudgetAsync(id, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a budget. Delete a budget. Transactions will not be deleted.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetApiResponse"/>&gt;</returns>
        public async Task<IDeleteBudgetApiResponse> DeleteBudgetAsync(string id, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteBudget(id);

                FormatDeleteBudget(ref id, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteBudgetApiResponse>();
                        DeleteBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteBudgetDefaultImplementation(apiResponseLocalVar, id, xTraceId);

                        Events.ExecuteOnDeleteBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteBudgetDefaultImplementation(e, "/v1/budgets/{id}", uriBuilderLocalVar.Path, id, xTraceId);
                Events.ExecuteOnErrorDeleteBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteBudgetApiResponse"/>
        /// </summary>
        public partial class DeleteBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IDeleteBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteBudgetApiResponse(ILogger<DeleteBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteBudgetApiResponse(ILogger<DeleteBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteBudgetLimit(ref string id, ref string limitId, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <returns></returns>
        private void ValidateDeleteBudgetLimit(string id, string limitId)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (limitId == null)
                throw new ArgumentNullException(nameof(limitId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        private void AfterDeleteBudgetLimitDefaultImplementation(IDeleteBudgetLimitApiResponse apiResponseLocalVar, string id, string limitId, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteBudgetLimit(ref suppressDefaultLog, apiResponseLocalVar, id, limitId, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        partial void AfterDeleteBudgetLimit(ref bool suppressDefaultLog, IDeleteBudgetLimitApiResponse apiResponseLocalVar, string id, string limitId, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorDeleteBudgetLimitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string limitId, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteBudgetLimit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, limitId, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorDeleteBudgetLimit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string limitId, Option<Guid> xTraceId);

        /// <summary>
        /// Delete a budget limit. Delete a budget limit.
        /// </summary>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IDeleteBudgetLimitApiResponse?> DeleteBudgetLimitOrDefaultAsync(string id, string limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteBudgetLimitAsync(id, limitId, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a budget limit. Delete a budget limit.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IDeleteBudgetLimitApiResponse> DeleteBudgetLimitAsync(string id, string limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteBudgetLimit(id, limitId);

                FormatDeleteBudgetLimit(ref id, ref limitId, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/limits/{limitId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/limits/{limitId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BlimitId%7D", Uri.EscapeDataString(limitId.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteBudgetLimitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteBudgetLimitApiResponse>();
                        DeleteBudgetLimitApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/limits/{limitId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteBudgetLimitDefaultImplementation(apiResponseLocalVar, id, limitId, xTraceId);

                        Events.ExecuteOnDeleteBudgetLimit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteBudgetLimitDefaultImplementation(e, "/v1/budgets/{id}/limits/{limitId}", uriBuilderLocalVar.Path, id, limitId, xTraceId);
                Events.ExecuteOnErrorDeleteBudgetLimit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteBudgetLimitApiResponse"/>
        /// </summary>
        public partial class DeleteBudgetLimitApiResponse : Brotal.FireflyIII.Client.ApiResponse, IDeleteBudgetLimitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteBudgetLimitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteBudgetLimitApiResponse(ILogger<DeleteBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteBudgetLimitApiResponse(ILogger<DeleteBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetBudget(ref string id, ref Option<Guid> xTraceId, ref Option<DateOnly> start, ref Option<DateOnly> end);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateGetBudget(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void AfterGetBudgetDefaultImplementation(IGetBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLog = false;
            AfterGetBudget(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId, start, end);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void AfterGetBudget(ref bool suppressDefaultLog, IGetBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void OnErrorGetBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId, start, end);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void OnErrorGetBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// Get a single budget. Get a single budget. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </summary>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetApiResponse"/>&gt;</returns>
        public async Task<IGetBudgetApiResponse?> GetBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBudgetAsync(id, xTraceId, start, end, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a single budget. Get a single budget. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetApiResponse"/>&gt;</returns>
        public async Task<IGetBudgetApiResponse> GetBudgetAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBudget(id);

                FormatGetBudget(ref id, ref xTraceId, ref start, ref end);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (end.IsSet)
                        parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBudgetApiResponse>();
                        GetBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetBudgetDefaultImplementation(apiResponseLocalVar, id, xTraceId, start, end);

                        Events.ExecuteOnGetBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBudgetDefaultImplementation(e, "/v1/budgets/{id}", uriBuilderLocalVar.Path, id, xTraceId, start, end);
                Events.ExecuteOnErrorGetBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBudgetApiResponse"/>
        /// </summary>
        public partial class GetBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IGetBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBudgetApiResponse(ILogger<GetBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBudgetApiResponse(ILogger<GetBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetBudgetLimit(ref string id, ref int limitId, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateGetBudgetLimit(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        private void AfterGetBudgetLimitDefaultImplementation(IGetBudgetLimitApiResponse apiResponseLocalVar, string id, int limitId, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterGetBudgetLimit(ref suppressDefaultLog, apiResponseLocalVar, id, limitId, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        partial void AfterGetBudgetLimit(ref bool suppressDefaultLog, IGetBudgetLimitApiResponse apiResponseLocalVar, string id, int limitId, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorGetBudgetLimitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, int limitId, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetBudgetLimit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, limitId, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorGetBudgetLimit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, int limitId, Option<Guid> xTraceId);

        /// <summary>
        /// Get single budget limit. 
        /// </summary>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IGetBudgetLimitApiResponse?> GetBudgetLimitOrDefaultAsync(string id, int limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetBudgetLimitAsync(id, limitId, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get single budget limit. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IGetBudgetLimitApiResponse> GetBudgetLimitAsync(string id, int limitId, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetBudgetLimit(id);

                FormatGetBudgetLimit(ref id, ref limitId, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/limits/{limitId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/limits/{limitId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BlimitId%7D", Uri.EscapeDataString(limitId.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetBudgetLimitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetBudgetLimitApiResponse>();
                        GetBudgetLimitApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/limits/{limitId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetBudgetLimitDefaultImplementation(apiResponseLocalVar, id, limitId, xTraceId);

                        Events.ExecuteOnGetBudgetLimit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetBudgetLimitDefaultImplementation(e, "/v1/budgets/{id}/limits/{limitId}", uriBuilderLocalVar.Path, id, limitId, xTraceId);
                Events.ExecuteOnErrorGetBudgetLimit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetBudgetLimitApiResponse"/>
        /// </summary>
        public partial class GetBudgetLimitApiResponse : Brotal.FireflyIII.Client.ApiResponse, IGetBudgetLimitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetBudgetLimitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBudgetLimitApiResponse(ILogger<GetBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetBudgetLimitApiResponse(ILogger<GetBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetLimitSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetLimitSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetLimitSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListAttachmentByBudget(ref string id, ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateListAttachmentByBudget(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterListAttachmentByBudgetDefaultImplementation(IListAttachmentByBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLog = false;
            AfterListAttachmentByBudget(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterListAttachmentByBudget(ref bool suppressDefaultLog, IListAttachmentByBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorListAttachmentByBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListAttachmentByBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorListAttachmentByBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page);

        /// <summary>
        /// Lists all attachments of a budget. Lists all attachments.
        /// </summary>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAttachmentByBudgetApiResponse"/>&gt;</returns>
        public async Task<IListAttachmentByBudgetApiResponse?> ListAttachmentByBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListAttachmentByBudgetAsync(id, xTraceId, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Lists all attachments of a budget. Lists all attachments.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAttachmentByBudgetApiResponse"/>&gt;</returns>
        public async Task<IListAttachmentByBudgetApiResponse> ListAttachmentByBudgetAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListAttachmentByBudget(id);

                FormatListAttachmentByBudget(ref id, ref xTraceId, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/attachments"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/attachments");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListAttachmentByBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListAttachmentByBudgetApiResponse>();
                        ListAttachmentByBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/attachments", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListAttachmentByBudgetDefaultImplementation(apiResponseLocalVar, id, xTraceId, limit, page);

                        Events.ExecuteOnListAttachmentByBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListAttachmentByBudgetDefaultImplementation(e, "/v1/budgets/{id}/attachments", uriBuilderLocalVar.Path, id, xTraceId, limit, page);
                Events.ExecuteOnErrorListAttachmentByBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListAttachmentByBudgetApiResponse"/>
        /// </summary>
        public partial class ListAttachmentByBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListAttachmentByBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListAttachmentByBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListAttachmentByBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListAttachmentByBudgetApiResponse(ILogger<ListAttachmentByBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListAttachmentByBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListAttachmentByBudgetApiResponse(ILogger<ListAttachmentByBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.AttachmentArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.AttachmentArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.AttachmentArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListBudget(ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page, ref Option<DateOnly> start, ref Option<DateOnly> end);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void AfterListBudgetDefaultImplementation(IListBudgetApiResponse apiResponseLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLog = false;
            AfterListBudget(ref suppressDefaultLog, apiResponseLocalVar, xTraceId, limit, page, start, end);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void AfterListBudget(ref bool suppressDefaultLog, IListBudgetApiResponse apiResponseLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void OnErrorListBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xTraceId, limit, page, start, end);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void OnErrorListBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// List all budgets. List all the budgets the user has made. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </summary>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetApiResponse"/>&gt;</returns>
        public async Task<IListBudgetApiResponse?> ListBudgetOrDefaultAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListBudgetAsync(xTraceId, limit, page, start, end, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all budgets. List all the budgets the user has made. If the start date and end date are submitted as well, the \&quot;spent\&quot; array will be updated accordingly.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD, to get info on how much the user has spent. You must submit both start and end.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetApiResponse"/>&gt;</returns>
        public async Task<IListBudgetApiResponse> ListBudgetAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatListBudget(ref xTraceId, ref limit, ref page, ref start, ref end);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (end.IsSet)
                        parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListBudgetApiResponse>();
                        ListBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListBudgetDefaultImplementation(apiResponseLocalVar, xTraceId, limit, page, start, end);

                        Events.ExecuteOnListBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListBudgetDefaultImplementation(e, "/v1/budgets", uriBuilderLocalVar.Path, xTraceId, limit, page, start, end);
                Events.ExecuteOnErrorListBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListBudgetApiResponse"/>
        /// </summary>
        public partial class ListBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBudgetApiResponse(ILogger<ListBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBudgetApiResponse(ILogger<ListBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListBudgetLimit(ref DateOnly start, ref DateOnly end, ref Option<Guid> xTraceId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        private void AfterListBudgetLimitDefaultImplementation(IListBudgetLimitApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterListBudgetLimit(ref suppressDefaultLog, apiResponseLocalVar, start, end, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        partial void AfterListBudgetLimit(ref bool suppressDefaultLog, IListBudgetLimitApiResponse apiResponseLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorListBudgetLimitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListBudgetLimit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, start, end, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorListBudgetLimit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, DateOnly start, DateOnly end, Option<Guid> xTraceId);

        /// <summary>
        /// Get list of budget limits by date Get all budget limits for for this date range. 
        /// </summary>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IListBudgetLimitApiResponse?> ListBudgetLimitOrDefaultAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListBudgetLimitAsync(start, end, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get list of budget limits by date Get all budget limits for for this date range. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="start">A date formatted YYYY-MM-DD. </param>
        /// <param name="end">A date formatted YYYY-MM-DD. </param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IListBudgetLimitApiResponse> ListBudgetLimitAsync(DateOnly start, DateOnly end, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatListBudgetLimit(ref start, ref end, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budget-limits"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budget-limits");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListBudgetLimitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListBudgetLimitApiResponse>();
                        ListBudgetLimitApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budget-limits", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListBudgetLimitDefaultImplementation(apiResponseLocalVar, start, end, xTraceId);

                        Events.ExecuteOnListBudgetLimit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListBudgetLimitDefaultImplementation(e, "/v1/budget-limits", uriBuilderLocalVar.Path, start, end, xTraceId);
                Events.ExecuteOnErrorListBudgetLimit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListBudgetLimitApiResponse"/>
        /// </summary>
        public partial class ListBudgetLimitApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListBudgetLimitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListBudgetLimitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBudgetLimitApiResponse(ILogger<ListBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBudgetLimitApiResponse(ILogger<ListBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetLimitArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetLimitArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetLimitArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListBudgetLimitByBudget(ref string id, ref Option<Guid> xTraceId, ref Option<DateOnly> start, ref Option<DateOnly> end);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateListBudgetLimitByBudget(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void AfterListBudgetLimitByBudgetDefaultImplementation(IListBudgetLimitByBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLog = false;
            AfterListBudgetLimitByBudget(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId, start, end);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void AfterListBudgetLimitByBudget(ref bool suppressDefaultLog, IListBudgetLimitByBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void OnErrorListBudgetLimitByBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListBudgetLimitByBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId, start, end);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void OnErrorListBudgetLimitByBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// Get all limits for a budget. Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \&quot;spent\&quot; array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
        /// </summary>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitByBudgetApiResponse"/>&gt;</returns>
        public async Task<IListBudgetLimitByBudgetApiResponse?> ListBudgetLimitByBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListBudgetLimitByBudgetAsync(id, xTraceId, start, end, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all limits for a budget. Get all budget limits for this budget and the money spent, and money left. You can limit the list by submitting a date range as well. The \&quot;spent\&quot; array for each budget limit is NOT influenced by the start and end date of your query, but by the start and end date of the budget limit itself. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the requested budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListBudgetLimitByBudgetApiResponse"/>&gt;</returns>
        public async Task<IListBudgetLimitByBudgetApiResponse> ListBudgetLimitByBudgetAsync(string id, Option<Guid> xTraceId = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListBudgetLimitByBudget(id);

                FormatListBudgetLimitByBudget(ref id, ref xTraceId, ref start, ref end);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/limits"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/limits");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (end.IsSet)
                        parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListBudgetLimitByBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListBudgetLimitByBudgetApiResponse>();
                        ListBudgetLimitByBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/limits", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListBudgetLimitByBudgetDefaultImplementation(apiResponseLocalVar, id, xTraceId, start, end);

                        Events.ExecuteOnListBudgetLimitByBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListBudgetLimitByBudgetDefaultImplementation(e, "/v1/budgets/{id}/limits", uriBuilderLocalVar.Path, id, xTraceId, start, end);
                Events.ExecuteOnErrorListBudgetLimitByBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListBudgetLimitByBudgetApiResponse"/>
        /// </summary>
        public partial class ListBudgetLimitByBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListBudgetLimitByBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListBudgetLimitByBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListBudgetLimitByBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBudgetLimitByBudgetApiResponse(ILogger<ListBudgetLimitByBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListBudgetLimitByBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListBudgetLimitByBudgetApiResponse(ILogger<ListBudgetLimitByBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetLimitArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetLimitArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetLimitArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListTransactionByBudget(ref string id, ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page, ref Option<DateOnly> start, ref Option<DateOnly> end, ref Option<TransactionTypeFilter> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateListTransactionByBudget(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="type"></param>
        private void AfterListTransactionByBudgetDefaultImplementation(IListTransactionByBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end, Option<TransactionTypeFilter> type)
        {
            bool suppressDefaultLog = false;
            AfterListTransactionByBudget(ref suppressDefaultLog, apiResponseLocalVar, id, xTraceId, limit, page, start, end, type);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="type"></param>
        partial void AfterListTransactionByBudget(ref bool suppressDefaultLog, IListTransactionByBudgetApiResponse apiResponseLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end, Option<TransactionTypeFilter> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="type"></param>
        private void OnErrorListTransactionByBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end, Option<TransactionTypeFilter> type)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListTransactionByBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, xTraceId, limit, page, start, end, type);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="type"></param>
        partial void OnErrorListTransactionByBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end, Option<TransactionTypeFilter> type);

        /// <summary>
        /// All transactions to a budget. Get all transactions linked to a budget, possibly limited by start and end
        /// </summary>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetApiResponse"/>&gt;</returns>
        public async Task<IListTransactionByBudgetApiResponse?> ListTransactionByBudgetOrDefaultAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListTransactionByBudgetAsync(id, xTraceId, limit, page, start, end, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// All transactions to a budget. Get all transactions linked to a budget, possibly limited by start and end
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetApiResponse"/>&gt;</returns>
        public async Task<IListTransactionByBudgetApiResponse> ListTransactionByBudgetAsync(string id, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListTransactionByBudget(id);

                FormatListTransactionByBudget(ref id, ref xTraceId, ref limit, ref page, ref start, ref end, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/transactions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/transactions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (end.IsSet)
                        parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListTransactionByBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListTransactionByBudgetApiResponse>();
                        ListTransactionByBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/transactions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListTransactionByBudgetDefaultImplementation(apiResponseLocalVar, id, xTraceId, limit, page, start, end, type);

                        Events.ExecuteOnListTransactionByBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListTransactionByBudgetDefaultImplementation(e, "/v1/budgets/{id}/transactions", uriBuilderLocalVar.Path, id, xTraceId, limit, page, start, end, type);
                Events.ExecuteOnErrorListTransactionByBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListTransactionByBudgetApiResponse"/>
        /// </summary>
        public partial class ListTransactionByBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListTransactionByBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListTransactionByBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListTransactionByBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTransactionByBudgetApiResponse(ILogger<ListTransactionByBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListTransactionByBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTransactionByBudgetApiResponse(ILogger<ListTransactionByBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.TransactionArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.TransactionArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.TransactionArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListTransactionByBudgetLimit(ref string id, ref string limitId, ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page, ref Option<TransactionTypeFilter> type);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <returns></returns>
        private void ValidateListTransactionByBudgetLimit(string id, string limitId)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (limitId == null)
                throw new ArgumentNullException(nameof(limitId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="type"></param>
        private void AfterListTransactionByBudgetLimitDefaultImplementation(IListTransactionByBudgetLimitApiResponse apiResponseLocalVar, string id, string limitId, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<TransactionTypeFilter> type)
        {
            bool suppressDefaultLog = false;
            AfterListTransactionByBudgetLimit(ref suppressDefaultLog, apiResponseLocalVar, id, limitId, xTraceId, limit, page, type);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="type"></param>
        partial void AfterListTransactionByBudgetLimit(ref bool suppressDefaultLog, IListTransactionByBudgetLimitApiResponse apiResponseLocalVar, string id, string limitId, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<TransactionTypeFilter> type);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="type"></param>
        private void OnErrorListTransactionByBudgetLimitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string limitId, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<TransactionTypeFilter> type)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListTransactionByBudgetLimit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, limitId, xTraceId, limit, page, type);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="type"></param>
        partial void OnErrorListTransactionByBudgetLimit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string limitId, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<TransactionTypeFilter> type);

        /// <summary>
        /// List all transactions by a budget limit ID. List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
        /// </summary>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IListTransactionByBudgetLimitApiResponse?> ListTransactionByBudgetLimitOrDefaultAsync(string id, string limitId, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListTransactionByBudgetLimitAsync(id, limitId, xTraceId, limit, page, type, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List all transactions by a budget limit ID. List all the transactions within one budget limit. The start and end date are dictated by the budget limit.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="type">Optional filter on the transaction type(s) returned (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionByBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IListTransactionByBudgetLimitApiResponse> ListTransactionByBudgetLimitAsync(string id, string limitId, Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<TransactionTypeFilter> type = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListTransactionByBudgetLimit(id, limitId);

                FormatListTransactionByBudgetLimit(ref id, ref limitId, ref xTraceId, ref limit, ref page, ref type);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/limits/{limitId}/transactions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/limits/{limitId}/transactions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BlimitId%7D", Uri.EscapeDataString(limitId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListTransactionByBudgetLimitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListTransactionByBudgetLimitApiResponse>();
                        ListTransactionByBudgetLimitApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/limits/{limitId}/transactions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListTransactionByBudgetLimitDefaultImplementation(apiResponseLocalVar, id, limitId, xTraceId, limit, page, type);

                        Events.ExecuteOnListTransactionByBudgetLimit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListTransactionByBudgetLimitDefaultImplementation(e, "/v1/budgets/{id}/limits/{limitId}/transactions", uriBuilderLocalVar.Path, id, limitId, xTraceId, limit, page, type);
                Events.ExecuteOnErrorListTransactionByBudgetLimit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListTransactionByBudgetLimitApiResponse"/>
        /// </summary>
        public partial class ListTransactionByBudgetLimitApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListTransactionByBudgetLimitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListTransactionByBudgetLimitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListTransactionByBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTransactionByBudgetLimitApiResponse(ILogger<ListTransactionByBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListTransactionByBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTransactionByBudgetLimitApiResponse(ILogger<ListTransactionByBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.TransactionArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.TransactionArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.TransactionArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListTransactionWithoutBudget(ref Option<Guid> xTraceId, ref Option<int> limit, ref Option<int> page, ref Option<DateOnly> start, ref Option<DateOnly> end);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void AfterListTransactionWithoutBudgetDefaultImplementation(IListTransactionWithoutBudgetApiResponse apiResponseLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLog = false;
            AfterListTransactionWithoutBudget(ref suppressDefaultLog, apiResponseLocalVar, xTraceId, limit, page, start, end);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void AfterListTransactionWithoutBudget(ref bool suppressDefaultLog, IListTransactionWithoutBudgetApiResponse apiResponseLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        private void OnErrorListTransactionWithoutBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListTransactionWithoutBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, xTraceId, limit, page, start, end);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="xTraceId"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        partial void OnErrorListTransactionWithoutBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<Guid> xTraceId, Option<int> limit, Option<int> page, Option<DateOnly> start, Option<DateOnly> end);

        /// <summary>
        /// All transactions without a budget. Get all transactions NOT linked to a budget, possibly limited by start and end
        /// </summary>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionWithoutBudgetApiResponse"/>&gt;</returns>
        public async Task<IListTransactionWithoutBudgetApiResponse?> ListTransactionWithoutBudgetOrDefaultAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListTransactionWithoutBudgetAsync(xTraceId, limit, page, start, end, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// All transactions without a budget. Get all transactions NOT linked to a budget, possibly limited by start and end
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="limit">Number of items per page. The default pagination is per 50 items. (optional)</param>
        /// <param name="page">Page number. The default pagination is per 50 items. (optional)</param>
        /// <param name="start">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="end">A date formatted YYYY-MM-DD.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTransactionWithoutBudgetApiResponse"/>&gt;</returns>
        public async Task<IListTransactionWithoutBudgetApiResponse> ListTransactionWithoutBudgetAsync(Option<Guid> xTraceId = default, Option<int> limit = default, Option<int> page = default, Option<DateOnly> start = default, Option<DateOnly> end = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatListTransactionWithoutBudget(ref xTraceId, ref limit, ref page, ref start, ref end);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/transactions-without-budget"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/transactions-without-budget");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (end.IsSet)
                        parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListTransactionWithoutBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListTransactionWithoutBudgetApiResponse>();
                        ListTransactionWithoutBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/transactions-without-budget", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListTransactionWithoutBudgetDefaultImplementation(apiResponseLocalVar, xTraceId, limit, page, start, end);

                        Events.ExecuteOnListTransactionWithoutBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListTransactionWithoutBudgetDefaultImplementation(e, "/v1/budgets/transactions-without-budget", uriBuilderLocalVar.Path, xTraceId, limit, page, start, end);
                Events.ExecuteOnErrorListTransactionWithoutBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListTransactionWithoutBudgetApiResponse"/>
        /// </summary>
        public partial class ListTransactionWithoutBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IListTransactionWithoutBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListTransactionWithoutBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListTransactionWithoutBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTransactionWithoutBudgetApiResponse(ILogger<ListTransactionWithoutBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListTransactionWithoutBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTransactionWithoutBudgetApiResponse(ILogger<ListTransactionWithoutBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.TransactionArray? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.TransactionArray>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.TransactionArray? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStoreBudget(BudgetStore budgetStore, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="budgetStore"></param>
        /// <returns></returns>
        private void ValidateStoreBudget(BudgetStore budgetStore)
        {
            if (budgetStore == null)
                throw new ArgumentNullException(nameof(budgetStore));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="budgetStore"></param>
        /// <param name="xTraceId"></param>
        private void AfterStoreBudgetDefaultImplementation(IStoreBudgetApiResponse apiResponseLocalVar, BudgetStore budgetStore, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterStoreBudget(ref suppressDefaultLog, apiResponseLocalVar, budgetStore, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="budgetStore"></param>
        /// <param name="xTraceId"></param>
        partial void AfterStoreBudget(ref bool suppressDefaultLog, IStoreBudgetApiResponse apiResponseLocalVar, BudgetStore budgetStore, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="budgetStore"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorStoreBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, BudgetStore budgetStore, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStoreBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, budgetStore, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="budgetStore"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorStoreBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, BudgetStore budgetStore, Option<Guid> xTraceId);

        /// <summary>
        /// Store a new budget Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
        /// </summary>
        /// <param name="budgetStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetApiResponse"/>&gt;</returns>
        public async Task<IStoreBudgetApiResponse?> StoreBudgetOrDefaultAsync(BudgetStore budgetStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await StoreBudgetAsync(budgetStore, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Store a new budget Creates a new budget. The data required can be submitted as a JSON body or as a list of parameters.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="budgetStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetApiResponse"/>&gt;</returns>
        public async Task<IStoreBudgetApiResponse> StoreBudgetAsync(BudgetStore budgetStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStoreBudget(budgetStore);

                FormatStoreBudget(budgetStore, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets");

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (budgetStore as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(budgetStore, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<StoreBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<StoreBudgetApiResponse>();
                        StoreBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterStoreBudgetDefaultImplementation(apiResponseLocalVar, budgetStore, xTraceId);

                        Events.ExecuteOnStoreBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorStoreBudgetDefaultImplementation(e, "/v1/budgets", uriBuilderLocalVar.Path, budgetStore, xTraceId);
                Events.ExecuteOnErrorStoreBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="StoreBudgetApiResponse"/>
        /// </summary>
        public partial class StoreBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IStoreBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<StoreBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="StoreBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreBudgetApiResponse(ILogger<StoreBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="StoreBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreBudgetApiResponse(ILogger<StoreBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatStoreBudgetLimit(ref string id, BudgetLimitStore budgetLimitStore, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="budgetLimitStore"></param>
        /// <returns></returns>
        private void ValidateStoreBudgetLimit(string id, BudgetLimitStore budgetLimitStore)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (budgetLimitStore == null)
                throw new ArgumentNullException(nameof(budgetLimitStore));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetLimitStore"></param>
        /// <param name="xTraceId"></param>
        private void AfterStoreBudgetLimitDefaultImplementation(IStoreBudgetLimitApiResponse apiResponseLocalVar, string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterStoreBudgetLimit(ref suppressDefaultLog, apiResponseLocalVar, id, budgetLimitStore, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetLimitStore"></param>
        /// <param name="xTraceId"></param>
        partial void AfterStoreBudgetLimit(ref bool suppressDefaultLog, IStoreBudgetLimitApiResponse apiResponseLocalVar, string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetLimitStore"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorStoreBudgetLimitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorStoreBudgetLimit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, budgetLimitStore, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetLimitStore"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorStoreBudgetLimit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId);

        /// <summary>
        /// Store new budget limit. Store a new budget limit under this budget.
        /// </summary>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetLimitStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IStoreBudgetLimitApiResponse?> StoreBudgetLimitOrDefaultAsync(string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await StoreBudgetLimitAsync(id, budgetLimitStore, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Store new budget limit. Store a new budget limit under this budget.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetLimitStore">JSON array or key&#x3D;value pairs with the necessary budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IStoreBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IStoreBudgetLimitApiResponse> StoreBudgetLimitAsync(string id, BudgetLimitStore budgetLimitStore, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateStoreBudgetLimit(id, budgetLimitStore);

                FormatStoreBudgetLimit(ref id, budgetLimitStore, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/limits"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/limits");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (budgetLimitStore as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(budgetLimitStore, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<StoreBudgetLimitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<StoreBudgetLimitApiResponse>();
                        StoreBudgetLimitApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/limits", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterStoreBudgetLimitDefaultImplementation(apiResponseLocalVar, id, budgetLimitStore, xTraceId);

                        Events.ExecuteOnStoreBudgetLimit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorStoreBudgetLimitDefaultImplementation(e, "/v1/budgets/{id}/limits", uriBuilderLocalVar.Path, id, budgetLimitStore, xTraceId);
                Events.ExecuteOnErrorStoreBudgetLimit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="StoreBudgetLimitApiResponse"/>
        /// </summary>
        public partial class StoreBudgetLimitApiResponse : Brotal.FireflyIII.Client.ApiResponse, IStoreBudgetLimitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<StoreBudgetLimitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="StoreBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreBudgetLimitApiResponse(ILogger<StoreBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="StoreBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public StoreBudgetLimitApiResponse(ILogger<StoreBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetLimitSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetLimitSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetLimitSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateBudget(ref string id, BudgetUpdate budgetUpdate, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="budgetUpdate"></param>
        /// <returns></returns>
        private void ValidateUpdateBudget(string id, BudgetUpdate budgetUpdate)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (budgetUpdate == null)
                throw new ArgumentNullException(nameof(budgetUpdate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetUpdate"></param>
        /// <param name="xTraceId"></param>
        private void AfterUpdateBudgetDefaultImplementation(IUpdateBudgetApiResponse apiResponseLocalVar, string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterUpdateBudget(ref suppressDefaultLog, apiResponseLocalVar, id, budgetUpdate, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetUpdate"></param>
        /// <param name="xTraceId"></param>
        partial void AfterUpdateBudget(ref bool suppressDefaultLog, IUpdateBudgetApiResponse apiResponseLocalVar, string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetUpdate"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorUpdateBudgetDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateBudget(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, budgetUpdate, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="budgetUpdate"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorUpdateBudget(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId);

        /// <summary>
        /// Update existing budget. Update existing budget. This endpoint cannot be used to set budget amount limits.
        /// </summary>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetUpdate">JSON array with updated budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetApiResponse"/>&gt;</returns>
        public async Task<IUpdateBudgetApiResponse?> UpdateBudgetOrDefaultAsync(string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateBudgetAsync(id, budgetUpdate, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update existing budget. Update existing budget. This endpoint cannot be used to set budget amount limits.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget.</param>
        /// <param name="budgetUpdate">JSON array with updated budget information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetApiResponse"/>&gt;</returns>
        public async Task<IUpdateBudgetApiResponse> UpdateBudgetAsync(string id, BudgetUpdate budgetUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateBudget(id, budgetUpdate);

                FormatUpdateBudget(ref id, budgetUpdate, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (budgetUpdate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(budgetUpdate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateBudgetApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateBudgetApiResponse>();
                        UpdateBudgetApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateBudgetDefaultImplementation(apiResponseLocalVar, id, budgetUpdate, xTraceId);

                        Events.ExecuteOnUpdateBudget(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateBudgetDefaultImplementation(e, "/v1/budgets/{id}", uriBuilderLocalVar.Path, id, budgetUpdate, xTraceId);
                Events.ExecuteOnErrorUpdateBudget(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateBudgetApiResponse"/>
        /// </summary>
        public partial class UpdateBudgetApiResponse : Brotal.FireflyIII.Client.ApiResponse, IUpdateBudgetApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateBudgetApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateBudgetApiResponse(ILogger<UpdateBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateBudgetApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateBudgetApiResponse(ILogger<UpdateBudgetApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateBudgetLimit(ref string id, ref string limitId, BudgetLimitUpdate budgetLimitUpdate, ref Option<Guid> xTraceId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="budgetLimitUpdate"></param>
        /// <returns></returns>
        private void ValidateUpdateBudgetLimit(string id, string limitId, BudgetLimitUpdate budgetLimitUpdate)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (limitId == null)
                throw new ArgumentNullException(nameof(limitId));

            if (budgetLimitUpdate == null)
                throw new ArgumentNullException(nameof(budgetLimitUpdate));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="budgetLimitUpdate"></param>
        /// <param name="xTraceId"></param>
        private void AfterUpdateBudgetLimitDefaultImplementation(IUpdateBudgetLimitApiResponse apiResponseLocalVar, string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLog = false;
            AfterUpdateBudgetLimit(ref suppressDefaultLog, apiResponseLocalVar, id, limitId, budgetLimitUpdate, xTraceId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="budgetLimitUpdate"></param>
        /// <param name="xTraceId"></param>
        partial void AfterUpdateBudgetLimit(ref bool suppressDefaultLog, IUpdateBudgetLimitApiResponse apiResponseLocalVar, string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="budgetLimitUpdate"></param>
        /// <param name="xTraceId"></param>
        private void OnErrorUpdateBudgetLimitDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateBudgetLimit(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, limitId, budgetLimitUpdate, xTraceId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="limitId"></param>
        /// <param name="budgetLimitUpdate"></param>
        /// <param name="xTraceId"></param>
        partial void OnErrorUpdateBudgetLimit(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId);

        /// <summary>
        /// Update existing budget limit. Update existing budget limit.
        /// </summary>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="budgetLimitUpdate">JSON array with updated budget limit information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IUpdateBudgetLimitApiResponse?> UpdateBudgetLimitOrDefaultAsync(string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateBudgetLimitAsync(id, limitId, budgetLimitUpdate, xTraceId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update existing budget limit. Update existing budget limit.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The ID of the budget. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="limitId">The ID of the budget limit. The budget limit MUST be associated to the budget ID.</param>
        /// <param name="budgetLimitUpdate">JSON array with updated budget limit information. See the model for the exact specifications.</param>
        /// <param name="xTraceId">Unique identifier associated with this request. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateBudgetLimitApiResponse"/>&gt;</returns>
        public async Task<IUpdateBudgetLimitApiResponse> UpdateBudgetLimitAsync(string id, string limitId, BudgetLimitUpdate budgetLimitUpdate, Option<Guid> xTraceId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateBudgetLimit(id, limitId, budgetLimitUpdate);

                FormatUpdateBudgetLimit(ref id, ref limitId, budgetLimitUpdate, ref xTraceId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/budgets/{id}/limits/{limitId}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/budgets/{id}/limits/{limitId}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BlimitId%7D", Uri.EscapeDataString(limitId.ToString()));

                    if (xTraceId.IsSet)
                        httpRequestMessageLocalVar.Headers.Add("X-Trace-Id", ClientUtils.ParameterToString(xTraceId.Value));

                    httpRequestMessageLocalVar.Content = (budgetLimitUpdate as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(budgetLimitUpdate, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    OAuthToken oauthTokenLocalVar1 = (OAuthToken) await OauthTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(oauthTokenLocalVar1);

                    oauthTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    BearerToken bearerTokenLocalVar2 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar2);

                    bearerTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json",
                        "application/x-www-form-urlencoded"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/vnd.api+json",
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateBudgetLimitApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateBudgetLimitApiResponse>();
                        UpdateBudgetLimitApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/budgets/{id}/limits/{limitId}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateBudgetLimitDefaultImplementation(apiResponseLocalVar, id, limitId, budgetLimitUpdate, xTraceId);

                        Events.ExecuteOnUpdateBudgetLimit(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateBudgetLimitDefaultImplementation(e, "/v1/budgets/{id}/limits/{limitId}", uriBuilderLocalVar.Path, id, limitId, budgetLimitUpdate, xTraceId);
                Events.ExecuteOnErrorUpdateBudgetLimit(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateBudgetLimitApiResponse"/>
        /// </summary>
        public partial class UpdateBudgetLimitApiResponse : Brotal.FireflyIII.Client.ApiResponse, IUpdateBudgetLimitApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateBudgetLimitApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateBudgetLimitApiResponse(ILogger<UpdateBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateBudgetLimitApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateBudgetLimitApiResponse(ILogger<UpdateBudgetLimitApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BudgetLimitSingle? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BudgetLimitSingle>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Brotal.FireflyIII.Model.BudgetLimitSingle? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public bool IsUnprocessableContent => 422 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 422 UnprocessableContent
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.ValidationErrorResponse? UnprocessableContent()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnprocessableContent
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.ValidationErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 422 UnprocessableContent and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnprocessableContent([NotNullWhen(true)]out Brotal.FireflyIII.Model.ValidationErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnprocessableContent();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)422);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.UnauthenticatedResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.UnauthenticatedResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out Brotal.FireflyIII.Model.UnauthenticatedResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.NotFoundResponse? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.NotFoundResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out Brotal.FireflyIII.Model.NotFoundResponse? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.BadRequestResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.BadRequestResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out Brotal.FireflyIII.Model.BadRequestResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public Brotal.FireflyIII.Model.InternalExceptionResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<Brotal.FireflyIII.Model.InternalExceptionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out Brotal.FireflyIII.Model.InternalExceptionResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
